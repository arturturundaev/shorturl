
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>shortener: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/arturturundaev/shorturl/cmd/shortener/main.go (0.0%)</option>
				
				<option value="file1">github.com/arturturundaev/shorturl/internal/app/handler/batch/batch_handler.go (85.0%)</option>
				
				<option value="file2">github.com/arturturundaev/shorturl/internal/app/handler/batch/batch_request.go (83.3%)</option>
				
				<option value="file3">github.com/arturturundaev/shorturl/internal/app/handler/delete/delete_handler.go (87.5%)</option>
				
				<option value="file4">github.com/arturturundaev/shorturl/internal/app/handler/find/find_handler.go (72.7%)</option>
				
				<option value="file5">github.com/arturturundaev/shorturl/internal/app/handler/ping/ping_handler.go (66.7%)</option>
				
				<option value="file6">github.com/arturturundaev/shorturl/internal/app/handler/save/save_handler.go (64.7%)</option>
				
				<option value="file7">github.com/arturturundaev/shorturl/internal/app/handler/shorten/shorten_handler.go (70.6%)</option>
				
				<option value="file8">github.com/arturturundaev/shorturl/internal/app/handler/shorten/shorten_request.go (100.0%)</option>
				
				<option value="file9">github.com/arturturundaev/shorturl/internal/app/handler/user/url_handler.go (92.9%)</option>
				
				<option value="file10">github.com/arturturundaev/shorturl/internal/app/handler/user/url_list_response.go (100.0%)</option>
				
				<option value="file11">github.com/arturturundaev/shorturl/internal/app/middleware/jwt.go (62.2%)</option>
				
				<option value="file12">github.com/arturturundaev/shorturl/internal/app/repository/filestorage/file_storage_repository.go (0.0%)</option>
				
				<option value="file13">github.com/arturturundaev/shorturl/internal/app/repository/localstorage/local_storage_repository.go (0.0%)</option>
				
				<option value="file14">github.com/arturturundaev/shorturl/internal/app/repository/postgres/postgres.go (0.0%)</option>
				
				<option value="file15">github.com/arturturundaev/shorturl/internal/app/service/ping_service.go (0.0%)</option>
				
				<option value="file16">github.com/arturturundaev/shorturl/internal/app/service/short_url_service.go (71.2%)</option>
				
				<option value="file17">github.com/arturturundaev/shorturl/internal/app/utils/short_url_generator.go (0.0%)</option>
				
				<option value="file18">github.com/arturturundaev/shorturl/internal/config/config.go (51.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "fmt"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        deleteUrl "github.com/arturturundaev/shorturl/internal/app/handler/delete"
        "github.com/arturturundaev/shorturl/internal/app/handler/find"
        "github.com/arturturundaev/shorturl/internal/app/handler/ping"
        "github.com/arturturundaev/shorturl/internal/app/handler/save"
        "github.com/arturturundaev/shorturl/internal/app/handler/shorten"
        "github.com/arturturundaev/shorturl/internal/app/handler/user"
        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/arturturundaev/shorturl/internal/app/repository/filestorage"
        "github.com/arturturundaev/shorturl/internal/app/repository/localstorage"
        pg "github.com/arturturundaev/shorturl/internal/app/repository/postgres"
        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/arturturundaev/shorturl/internal/config"
        "github.com/gin-contrib/gzip"
        "github.com/gin-contrib/pprof"
        ginzap "github.com/gin-contrib/zap"
        "github.com/gin-gonic/gin"
        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/pgx/v5"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/jmoiron/sqlx"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "io"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "time"
)

// -d=postgres://postgres:postgres@localhost:5432/shorturl?sslmode=disable
// SaveFullURL создание
const SaveFullURL = `/`

// GetFullURL получение
const GetFullURL = `/:short`

// SaveFullURL2 v2
const SaveFullURL2 = `/api/shorten`

// SaveBatch массовое сохранение
const SaveBatch = `/api/shorten/batch`

// Ping пинг
const Ping = `/ping`

// URLByUser получение по пользователю
const URLByUser = `/api/user/urls`

// DeleteByUrls удаление ссылок
const DeleteByUrls = `/api/user/urls`

func main() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        log.Println("panic occurred:", err)
                }</span>
        }()

        <span class="cov0" title="0">serverConfig := config.NewConfig()

        router := gin.Default()

        logger, err := addLogger(router, serverConfig.FullLog)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err.Error())
                os.Exit(5)
        }</span>

        <span class="cov0" title="0">repositoryRead, repositoryWrite := getRepository(serverConfig, logger)

        if repositoryRead == nil </span><span class="cov0" title="0">{
                logger.Error("ошибка инициализации репозитория на чтение. Тип репозитория: " + config.StorageTypeDB)
        }</span>

        <span class="cov0" title="0">if repositoryWrite == nil </span><span class="cov0" title="0">{
                logger.Error("ошибка инициализации репозитория на запись. Тип репозитория: " + config.StorageTypeDB)
        }</span>

        <span class="cov0" title="0">if serverConfig.StorageType == config.StorageTypeDB </span><span class="cov0" title="0">{
                absPath, errPathMigration := filepath.Abs(".")
                if errPathMigration != nil </span><span class="cov0" title="0">{
                        logger.Error("ошибка определения директории для миграций!")
                }</span> else<span class="cov0" title="0"> {
                        initMigrations("file:////"+absPath+"/internal/app/repository/postgres/migration", repositoryRead.GetDB())
                }</span>
        }

        <span class="cov0" title="0">jwtValidate := middleware.NewJWTValidator(serverConfig.AddressStart.URL)

        shortURLService := service.NewShortURLService(repositoryRead, repositoryWrite)

        pingService := service.NewPingService(repositoryRead)

        handlerFind := find.NewFindHandler(shortURLService)
        handlerSave := save.NewSaveHandler(shortURLService, serverConfig.BaseShort.URL)
        handlerSave2 := shorten.NewShortenHandler(shortURLService, serverConfig.BaseShort.URL)
        handlerPing := ping.NewPingHandler(pingService)
        handlerButch := batch.NewButchHandler(shortURLService, serverConfig.BaseShort.URL)
        handlerFindByUser := user.NewURLFindByUserHandler(shortURLService, serverConfig.BaseShort.URL)
        handlerDelete := deleteUrl.NewDeleteHandler(shortURLService)

        router.Use(gzip.Gzip(gzip.DefaultCompression, gzip.WithDecompressFn(gzip.DefaultDecompressHandle)))

        router.GET(Ping, handlerPing.Handle)
        router.POST(SaveFullURL, jwtValidate.Handle, handlerSave.Handle)
        router.GET(GetFullURL, handlerFind.Handle)
        router.POST(SaveFullURL2, jwtValidate.Handle, handlerSave2.Handle)
        router.POST(SaveBatch, handlerButch.Handle)
        router.GET(URLByUser, jwtValidate.Handle, handlerFindByUser.Handle)
        router.DELETE(DeleteByUrls, jwtValidate.Handle, handlerDelete.Handle)

        pprof.Register(router, "dev/pprof")

        logger.Info("server start on port: " + serverConfig.AddressStart.String())

        errServer := http.ListenAndServe(serverConfig.AddressStart.String(), router)
        if errServer != nil </span><span class="cov0" title="0">{
                logger.Fatal(errServer.Error())
        }</span>
}

func addLogger(r *gin.Engine, fullLogger bool) (*zap.Logger, error) <span class="cov0" title="0">{
        logger, err := zap.NewProduction()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if fullLogger </span><span class="cov0" title="0">{
                r.Use(ginzap.Ginzap(logger, time.RFC3339, true))
                r.Use(ginzap.RecoveryWithZap(logger, true))
                r.Use(ginzap.GinzapWithConfig(logger, &amp;ginzap.Config{
                        UTC:        true,
                        TimeFormat: time.RFC3339,
                        Context: ginzap.Fn(func(c *gin.Context) []zapcore.Field </span><span class="cov0" title="0">{
                                var fields []zapcore.Field
                                // log request ID
                                if requestID := c.Writer.Header().Get("X-Request-Id"); requestID != "" </span><span class="cov0" title="0">{
                                        fields = append(fields, zap.String("request_id", requestID))
                                }</span>

                                // log request body
                                <span class="cov0" title="0">var body []byte
                                var buf bytes.Buffer
                                tee := io.TeeReader(c.Request.Body, &amp;buf)
                                body, _ = io.ReadAll(tee)
                                c.Request.Body = io.NopCloser(&amp;buf)
                                fields = append(fields, zap.String("body", string(body)))

                                return fields</span>
                        }),
                }))
        }

        <span class="cov0" title="0">return logger, nil</span>
}

func initMigrations(migrationPath string, DB *sqlx.DB) <span class="cov0" title="0">{
        driver, err := postgres.WithInstance(DB.DB, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                migrationPath,
                "postgres", driver)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span> else<span class="cov0" title="0"> {
                errMigrate := m.Up()
                if errMigrate != nil &amp;&amp; errMigrate.Error() != "no change" </span><span class="cov0" title="0">{
                        log.Fatal(errMigrate)
                }</span>
        }
}

func getRepository(serverConfig *config.Config, logger *zap.Logger) (service.RepositoryReader, service.RepositoryWriter) <span class="cov0" title="0">{

        if serverConfig.StorageType == config.StorageTypeDB </span><span class="cov0" title="0">{
                repository, errPingRepo := pg.NewPostgresRepository(serverConfig.DatabaseURL.URL)
                if errPingRepo != nil </span><span class="cov0" title="0">{
                        logger.Error(errPingRepo.Error())
                }</span>

                <span class="cov0" title="0">return repository, repository</span>
        }

        <span class="cov0" title="0">if serverConfig.StorageType == config.StorageTypeFile </span><span class="cov0" title="0">{
                repositoryWrite, errStorageWrite := filestorage.NewFileStorageRepositoryWrite(serverConfig.FileStorage.Path)
                if errStorageWrite != nil </span><span class="cov0" title="0">{
                        logger.Error(errStorageWrite.Error())
                }</span>

                <span class="cov0" title="0">repositoryRead, errStorageRead := filestorage.NewFileStorageRepositoryRead(serverConfig.FileStorage.Path)
                if errStorageRead != nil </span><span class="cov0" title="0">{
                        logger.Error(errStorageRead.Error())
                }</span>

                <span class="cov0" title="0">return repositoryRead, repositoryWrite</span>
        }

        <span class="cov0" title="0">if serverConfig.StorageType == config.StorageTypeMemory </span><span class="cov0" title="0">{
                repositoryWrite := localstorage.NewLocalStorageRepository()

                return repositoryWrite, repositoryWrite
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package batch

import (
        "encoding/json"
        "fmt"
        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/gin-gonic/gin"
        "net/http"
)

type serviceURLButcher interface {
        Batch(request []ButchRequest) ([]entity.ShortURLEntity, error)
}

// ButchHandler ButchHandler
type ButchHandler struct {
        service serviceURLButcher
        baseURL string
}

// NewButchHandler конструктор
func NewButchHandler(service serviceURLButcher, baseURL string) *ButchHandler <span class="cov0" title="0">{
        return &amp;ButchHandler{service: service, baseURL: baseURL}
}</span>

// Handle массовоt создание
func (h *ButchHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        var response []ButchResponse
        request, err := NewButchRequest(ctx)
        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">models, err := h.service.Batch(request)
        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">for _, model := range models </span><span class="cov8" title="1">{
                response = append(response, ButchResponse{CorrelationID: model.CorrelationID, ShortURL: fmt.Sprintf("%s/%s", h.baseURL, model.ShortURL)})
        }</span>

        <span class="cov8" title="1">bt, errMarshal := json.Marshal(response)

        if errMarshal != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": errMarshal.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.Writer.Header().Set("Accept-Encoding", "gzip")
        ctx.Writer.Header().Set("Content-Encoding", "gzip")
        ctx.Writer.Header().Set("Content-Type", "application/json")
        ctx.Data(http.StatusCreated, "gzip", bt)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package batch

import (
        "fmt"

        "github.com/gin-gonic/gin"
)

// ButchRequest dto
type ButchRequest struct {
        CorrelationID string `json:"correlation_id"`
        OriginalURL   string `json:"original_url"`
}

// NewButchRequest конструктор
func NewButchRequest(context *gin.Context) ([]ButchRequest, error) <span class="cov8" title="1">{
        var dto []ButchRequest

        if err := context.BindJSON(&amp;dto); err != nil </span><span class="cov8" title="1">{
                return dto, err
        }</span>

        <span class="cov8" title="1">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("пустой входной массив")
        }</span>

        <span class="cov8" title="1">return dto, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package delete

import (
        "encoding/json"
        "io"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/gin-gonic/gin"
)

type deleter interface {
        Delete(URLList []string, addedUserID string)
}

// DeleteHandler сервис
type DeleteHandler struct {
        service deleter
}

// NewDeleteHandler конструктор
func NewDeleteHandler(service deleter) *DeleteHandler <span class="cov8" title="1">{
        return &amp;DeleteHandler{service: service}
}</span>

// Handle обработчик удаления
func (h *DeleteHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        var data []string
        body, err := io.ReadAll(ctx.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(body, &amp;data)
        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov8" title="1">addedUserID, exists := ctx.Get(middleware.UserIDProperty)

        if !exists </span><span class="cov8" title="1">{
                ctx.Status(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">go h.service.Delete(data, addedUserID.(string))

        ctx.Status(http.StatusAccepted)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package find

import (
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/gin-gonic/gin"
)

// FindHandler сервис
type FindHandler struct {
        service *service.ShortURLService
}

// NewFindHandler конструктор
func NewFindHandler(service *service.ShortURLService) *FindHandler <span class="cov8" title="1">{
        return &amp;FindHandler{service: service}
}</span>

// Handle обработчик поиска
func (hndlr *FindHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{

        data, err := hndlr.service.FindByShortURL(ctx.Param("short"))

        if err != nil || data == nil </span><span class="cov8" title="1">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">if data.IsDeleted </span><span class="cov0" title="0">{
                ctx.Status(http.StatusGone)
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">ctx.Redirect(http.StatusTemporaryRedirect, data.URL)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package ping

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

type pignger interface {
        Ping(ctx context.Context) error
}

// PingHandler сервис
type PingHandler struct {
        service pignger
}

// NewPingHandler конструктор
func NewPingHandler(service pignger) *PingHandler <span class="cov0" title="0">{
        return &amp;PingHandler{service: service}
}</span>

// Handle обработчик поиска
func (h *PingHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{

        contxt, cancel := context.WithCancel(ctx)
        defer cancel()
        time.AfterFunc(1500*time.Millisecond, cancel)

        err := h.service.Ping(contxt)

        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.AbortWithStatusJSON(http.StatusOK, "")</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package save

import (
        "errors"
        "io"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/gin-gonic/gin"
)

// SaveHandler сервис
type SaveHandler struct {
        service *service.ShortURLService
        baseURL string
}

// NewSaveHandler конструктор
func NewSaveHandler(service *service.ShortURLService, baseURL string) *SaveHandler <span class="cov8" title="1">{
        return &amp;SaveHandler{service: service, baseURL: baseURL}
}</span>

// Handle обработчик сохранения
func (hndlr *SaveHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        b, err := io.ReadAll(ctx.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">data, err := hndlr.service.Save(ctx, string(b))

        if errors.Is(err, service.ErrEntityExists) </span><span class="cov0" title="0">{
                ctx.Header("Content-type", "text/plain")
                ctx.String(http.StatusConflict, "%s/%s", hndlr.baseURL, data.ShortURL)
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">ctx.Header("Content-type", "text/plain")
        ctx.String(http.StatusCreated, "%s/%s", hndlr.baseURL, data.ShortURL)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package shorten

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/gin-gonic/gin"
)

// Handle интерфейс для сохранения
type URLSaver interface {
        Save(ctx *gin.Context, url string) (*entity.ShortURLEntity, error)
}

// Handle сервис
type ShortenHandler struct {
        service URLSaver
        baseURL string
}

// Handle конструктор
func NewShortenHandler(service URLSaver, baseURL string) *ShortenHandler <span class="cov8" title="1">{
        return &amp;ShortenHandler{service: service, baseURL: baseURL}
}</span>

// Handle обаботчик
func (h *ShortenHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        dto, errGenerateShortURL := NewShortenRequest(ctx)

        if errGenerateShortURL != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": errGenerateShortURL.Error()})
                return
        }</span>

        <span class="cov8" title="1">if dto.URL == "" </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "Empty URL"})
                return
        }</span>

        <span class="cov8" title="1">data, errRepository := h.service.Save(ctx, dto.URL)

        if errRepository != nil &amp;&amp; !errors.Is(errRepository, service.ErrEntityExists) </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": errRepository.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := ShortenResponse{URL: fmt.Sprintf("%s/%s", h.baseURL, data.ShortURL)}

        status := http.StatusCreated

        if errors.Is(errRepository, service.ErrEntityExists) </span><span class="cov0" title="0">{
                status = http.StatusConflict
        }</span>

        <span class="cov8" title="1">ctx.JSON(status, response)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package shorten

import (
        "github.com/gin-gonic/gin"
)

// ShortenRequest dto
type ShortenRequest struct {
        URL string `json:"url" binding:"required"`
}

// NewShortenRequest конструктор
func NewShortenRequest(context *gin.Context) (*ShortenRequest, error) <span class="cov8" title="1">{
        dto := &amp;ShortenRequest{}

        if err := context.BindJSON(dto); err != nil </span><span class="cov8" title="1">{
                return dto, err
        }</span>

        <span class="cov8" title="1">return dto, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package user

import (
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/gin-gonic/gin"
)

// Handle интерфейс поиска ссылок по пользователю
type URLServiceFinder interface {
        GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error)
}

// Handle сервис
type URLFindByUserHandler struct {
        service URLServiceFinder
        baseURL string
}

// Handle конструктор
func NewURLFindByUserHandler(service URLServiceFinder, baseURL string) *URLFindByUserHandler <span class="cov0" title="0">{
        return &amp;URLFindByUserHandler{service: service, baseURL: baseURL}
}</span>

// Handle обработчик
func (handler *URLFindByUserHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        addedUserID, _ := ctx.Get(middleware.UserIDProperty)

        data, err := handler.service.GetUrlsByUserID(addedUserID.(string))

        if err != nil </span><span class="cov8" title="1">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">if len(data) == 0 </span><span class="cov8" title="1">{
                ctx.Status(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">var response []URLListItemResponse

        for _, url := range data </span><span class="cov8" title="1">{
                response = append(response, NewURLResponse(handler.baseURL, url.ShortURL, url.URL))
        }</span>
        <span class="cov8" title="1">ctx.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package user

import "fmt"

// URLListItemResponse dto
type URLListItemResponse struct {
        ShortURL  string `json:"short_url"`
        OriginURL string `json:"original_url"`
}

// NewURLResponse конструктор
func NewURLResponse(baseURL, shortURL, originURL string) URLListItemResponse <span class="cov8" title="1">{
        return URLListItemResponse{OriginURL: originURL, ShortURL: fmt.Sprintf("%s/%s", baseURL, shortURL)}
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// JWTValidator сервис
type JWTValidator struct {
        Claims Claims
        domain string
}

// Claims структура
type Claims struct {
        jwt.RegisteredClaims
        UserID string
}

// TokenExp время жизни токена
const TokenExp = 3 * time.Hour

// SecretKey ключ шифрования
const SecretKey = "0N#6Ke|+OR:(`G;"

// UserIDProperty в каком поле храниться ID пользователя
const UserIDProperty = "UserId"

// NewJWTValidator конструктор
func NewJWTValidator(domain string) *JWTValidator <span class="cov8" title="1">{
        return &amp;JWTValidator{domain: domain}
}</span>

// Handle обработка проверки токена
func (JWTValidator *JWTValidator) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        var err error
        token, _ := ctx.Cookie("Authorization")

        if token == "" </span><span class="cov8" title="1">{
                token, err = JWTValidator.BuildJWTString(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(http.StatusForbidden, err)
                }</span>
        } else<span class="cov0" title="0"> {
                errorValidateToken := JWTValidator.ValidateJWT(ctx, token)
                if errorValidateToken != nil </span><span class="cov0" title="0">{
                        token, err = JWTValidator.BuildJWTString(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                ctx.AbortWithStatusJSON(http.StatusForbidden, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">claims := &amp;Claims{}
        // парсим из строки токена tokenString в структуру claims
        jwt.ParseWithClaims(token, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(SecretKey), nil
        }</span>)

        <span class="cov8" title="1">ctx.Set(UserIDProperty, claims.UserID)
        ctx.Header("Authorization", token)

        ctx.SetCookie("Authorization", token, 100000, "*", JWTValidator.domain, false, true)</span>

}

// ValidateJWT проверка токена
func (JWTValidator *JWTValidator) ValidateJWT(ctx *gin.Context, tokenString string) error <span class="cov8" title="1">{
        claims := &amp;Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims,
                func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return []byte(SecretKey), nil</span>
                })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return fmt.Errorf("token is not valid")
        }</span>

        <span class="cov0" title="0">ctx.Set(UserIDProperty, claims.UserID)

        return nil</span>
}

// BuildJWTString формирование токена
func (JWTValidator *JWTValidator) BuildJWTString(ctx *gin.Context) (string, error) <span class="cov8" title="1">{
        userID := JWTValidator.getNewUserID()
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(TokenExp)),
                },
                UserID: userID,
        })

        tokenString, err := token.SignedString([]byte(SecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">ctx.Set(UserIDProperty, userID)

        return tokenString, nil</span>
}

func (JWTValidator *JWTValidator) getNewUserID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package filestorage

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/jmoiron/sqlx"
)

// FileStorageReadRepository сервис
type FileStorageReadRepository struct {
        file *os.File
}

// Find поиск
func (repo *FileStorageReadRepository) Find(shortURLs []string, addedUserID string) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// GetUrlsByUserID получение ссылок по пользователю
func (repo *FileStorageReadRepository) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        var models []entity.ShortURLEntity

        return models, nil
}</span>

// GetDB получение коннекта к репозиторию на чтение
func (repo *FileStorageReadRepository) GetDB() *sqlx.DB <span class="cov0" title="0">{
        return nil
}</span>

// GetDB получение коннекта к репозиторию на запись
func (repo *FileStorageWriteRepository) GetDB() *sqlx.DB <span class="cov0" title="0">{
        return nil
}</span>

// Ping  пинг
func (repo *FileStorageReadRepository) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// FileStorageWriteRepository сервис
type FileStorageWriteRepository struct {
        file *os.File
}

// Batch Массовое сохранение
func (repo *FileStorageWriteRepository) Batch(ents []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        var models []entity.ShortURLEntity
        var shortURL string
        for _, ent := range ents </span><span class="cov0" title="0">{
                shortURL = utils.GenerateShortURL(ent.OriginalURL)
                _, err := repo.file.WriteString(fmt.Sprintf(`{"short_url":"%s","original_url":"%s", "correlation_id":"%s"}`+"\n", shortURL, ent.OriginalURL, ent.CorrelationID))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">models = append(models, entity.ShortURLEntity{ShortURL: shortURL, URL: ent.OriginalURL, CorrelationID: ent.CorrelationID})</span>
        }

        <span class="cov0" title="0">return models, nil</span>
}

// NewFileStorageRepositoryWrite контсруктор на запись
func NewFileStorageRepositoryWrite(path string) (*FileStorageWriteRepository, error) <span class="cov0" title="0">{
        file, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;FileStorageWriteRepository{file: file}, nil</span>
}

// NewFileStorageRepositoryRead контсруктор на чтение
func NewFileStorageRepositoryRead(path string) (*FileStorageReadRepository, error) <span class="cov0" title="0">{
        file, err := os.OpenFile(path, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;FileStorageReadRepository{file: file}, nil</span>
}

// FindByShortURL поиск по короткой ссылке
func (repo *FileStorageReadRepository) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov0" title="0">{
        var dto entity.ShortURLEntity

        _, err := repo.file.Seek(0, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">scanner := bufio.NewScanner(repo.file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                if strings.Contains(scanner.Text(), shortURL) </span><span class="cov0" title="0">{
                        err := json.Unmarshal(scanner.Bytes(), &amp;dto)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;dto, nil</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// Save сохранение
func (repo *FileStorageWriteRepository) Save(shortURL, URL, addedUserID string) error <span class="cov0" title="0">{
        _, err := repo.file.WriteString(fmt.Sprintf(`{"short_url":"%s","original_url":"%s", "added_user_id":"%s"}`+"\n", shortURL, URL, addedUserID))

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete удаление
func (repo *FileStorageWriteRepository) Delete(shortURLs []string, addedUserID string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package localstorage

import (
        "context"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/jmoiron/sqlx"
)

// LocalStorageRepository сервис
type LocalStorageRepository struct {
        Rows map[string]LocalStorageRow
}

// GetUrlsByUserID получение ссылок по пользователю
func (repo *LocalStorageRepository) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        var models []entity.ShortURLEntity
        return models, nil
}</span>

// LocalStorageRow сервис
type LocalStorageRow struct {
        ShortURL      string
        URL           string
        CorrelationID string
        AddedUserID   string
}

// Batch Массовое сохранение
func (repo *LocalStorageRepository) Batch(ents []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        var shortURL string
        var models []entity.ShortURLEntity
        for _, ent := range ents </span><span class="cov0" title="0">{
                shortURL = utils.GenerateShortURL(ent.OriginalURL)
                repo.Rows[shortURL] = LocalStorageRow{ShortURL: shortURL, URL: ent.OriginalURL, CorrelationID: ent.CorrelationID}
                models = append(models, entity.ShortURLEntity{ShortURL: shortURL, URL: ent.OriginalURL, CorrelationID: ent.CorrelationID})
        }</span>

        <span class="cov0" title="0">return models, nil</span>
}

// NewLocalStorageRepository конструктор
func NewLocalStorageRepository() *LocalStorageRepository <span class="cov0" title="0">{
        return &amp;LocalStorageRepository{
                Rows: make(map[string]LocalStorageRow),
        }
}</span>

// FindByShortURL поиск по короткой ссылке
func (repo *LocalStorageRepository) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov0" title="0">{
        if row, exists := repo.Rows[shortURL]; exists </span><span class="cov0" title="0">{
                return &amp;(entity.ShortURLEntity{ShortURL: row.ShortURL, URL: row.URL, CorrelationID: row.CorrelationID}), nil
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// Save сохранение
func (repo *LocalStorageRepository) Save(shortURL, URL, addedUserID string) error <span class="cov0" title="0">{
        repo.Rows[shortURL] = LocalStorageRow{ShortURL: shortURL, URL: URL, AddedUserID: addedUserID}

        return nil
}</span>

// Ping  пинг
func (repo *LocalStorageRepository) Ping(ctx context.Context) error <span class="cov0" title="0">{

        return nil
}</span>

// GetDB получение коннекта к репозиторию
func (repo *LocalStorageRepository) GetDB() *sqlx.DB <span class="cov0" title="0">{
        return nil
}</span>

// Delete удаление
func (repo *LocalStorageRepository) Delete(shortURLs []string, addedUserID string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package postgres

import (
        "context"
        "fmt"
        "strings"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// TableName имя таблицы
const TableName = "url"

// Количество записей на одну вставвку
const ButchSize = 100

// PostgresRepository сервис
type PostgresRepository struct {
        DB *sqlx.DB
}

// NewPostgresRepository конструктор
func NewPostgresRepository(databaseURL string) (*PostgresRepository, error) <span class="cov0" title="0">{
        database, err := sqlx.Open("postgres", databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;PostgresRepository{DB: database}, nil</span>
}

// Ping  пинг
func (repo *PostgresRepository) Ping(ctx context.Context) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("прервали работу")</span>
        default:<span class="cov0" title="0">
                return repo.DB.Ping()</span>
        }
}

// FindByShortURL поиск по короткой ссылке
func (repo *PostgresRepository) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov0" title="0">{

        ent := []entity.ShortURLEntity{}
        err := repo.DB.Select(&amp;ent,
                fmt.Sprintf("select url_full as original_url, url_short, is_deleted from %s where url_short = $1", TableName),
                shortURL)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(ent) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return &amp;ent[0], nil</span>
}

// Save сохранение
func (repo *PostgresRepository) Save(shortURL, URL, addedUserID string) error <span class="cov0" title="0">{

        id := uuid.New().String()
        _, err := repo.DB.Exec(fmt.Sprintf(`INSERT into %s (id, url_full, url_short, added_user_id) values ($1, $2, $3, $4)`, TableName), id, URL, shortURL, addedUserID)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDB получение коннекта к репозиторию
func (repo *PostgresRepository) GetDB() *sqlx.DB <span class="cov0" title="0">{
        return repo.DB
}</span>

// Batch Массовое сохранение
func (repo *PostgresRepository) Batch(request []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        var models []entity.ShortURLEntity
        var allModels []entity.ShortURLEntity

        tx, err := repo.DB.Begin()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">k := 0
        var values []string
        var params []interface{}

        for i, item := range request </span><span class="cov0" title="0">{
                models = append(models, entity.ShortURLEntity{URL: item.OriginalURL, CorrelationID: item.CorrelationID, ShortURL: utils.GenerateShortURL(item.OriginalURL)})

                if len(models) == ButchSize || len(request) == i+1 </span><span class="cov0" title="0">{
                        values = nil
                        params = nil
                        for _, enty := range models </span><span class="cov0" title="0">{
                                values = append(values, "("+
                                        "$"+fmt.Sprintf("%d,", k+1)+
                                        "$"+fmt.Sprintf("%d,", k+2)+
                                        "$"+fmt.Sprintf("%d,", k+3)+
                                        "$"+fmt.Sprintf("%d", k+4)+")")
                                params = append(params, uuid.New().String(), enty.URL, enty.ShortURL, enty.CorrelationID)
                                k += 4
                        }</span>

                        <span class="cov0" title="0">valuesStr := strings.Join(values, ",")
                        _, err = repo.DB.Exec(fmt.Sprintf(`INSERT into %s values %s`, TableName, valuesStr), params...)
                        if err != nil </span><span class="cov0" title="0">{
                                err2 := tx.Rollback()
                                if err2 != nil </span><span class="cov0" title="0">{
                                        return nil, err2
                                }</span>
                                <span class="cov0" title="0">return nil, err</span>
                        }
                        <span class="cov0" title="0">allModels = append(allModels, models...)
                        models = nil</span>
                }
        }

        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return allModels, nil</span>
}

// GetUrlsByUserID получение ссылок по пользователю
func (repo *PostgresRepository) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        ent := []entity.ShortURLEntity{}

        err := repo.DB.Select(&amp;ent,
                fmt.Sprintf("select url_full as original_url, url_short from %s where added_user_id = $1", TableName),
                userID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ent, nil</span>
}

// Delete удаление
func (repo *PostgresRepository) Delete(shortURLs []string, addedUserID string) error <span class="cov0" title="0">{
        var inArray []string
        var params []interface{}

        params = append(params, addedUserID)
        i := 2
        for _, shortURL := range shortURLs </span><span class="cov0" title="0">{
                inArray = append(inArray, "$"+fmt.Sprintf("%d", i))
                params = append(params, shortURL)
                i++
        }</span>
        <span class="cov0" title="0">_, err := repo.DB.Exec(fmt.Sprintf(`update %s SET is_deleted = true WHERE added_user_id = $1 AND url_short IN (%s)`, TableName, strings.Join(inArray, ",")), params...)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package service

import "context"

// PingService сервис
type PingService struct {
        repository RepositoryReader
}

// NewPingService Конструктор
func NewPingService(repository RepositoryReader) *PingService <span class="cov0" title="0">{
        return &amp;PingService{repository: repository}
}</span>

// Ping пиннг
func (s *PingService) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return s.repository.Ping(ctx)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package service

import (
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// ShortURLService сервис
type ShortURLService struct {
        repositoryRead  RepositoryReader
        repositoryWrite RepositoryWriter
        logger          *zap.Logger
}

// ErrEntityExists ошибка нет записи
var ErrEntityExists = errors.New("entity exists")

// NewShortURLService конструктор
func NewShortURLService(repositoryRead RepositoryReader, repositoryWrite RepositoryWriter) *ShortURLService <span class="cov0" title="0">{
        return &amp;ShortURLService{repositoryRead: repositoryRead, repositoryWrite: repositoryWrite}
}</span>

// FindByShortURL поиск по короткой ссылке
func (service *ShortURLService) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov0" title="0">{
        return service.repositoryRead.FindByShortURL(shortURL)
}</span>

// Save сохранение
func (service *ShortURLService) Save(ctx *gin.Context, url string) (*entity.ShortURLEntity, error) <span class="cov0" title="0">{
        addedUserID, exists := ctx.Get(middleware.UserIDProperty)

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user id is required")
        }</span>

        <span class="cov0" title="0">shortURL := utils.GenerateShortURL(url)

        model, errRepository := service.repositoryRead.FindByShortURL(shortURL)

        if errRepository != nil </span><span class="cov0" title="0">{
                return nil, errRepository
        }</span>

        <span class="cov0" title="0">if model != nil </span><span class="cov0" title="0">{
                return model, ErrEntityExists
        }</span>

        <span class="cov0" title="0">err := service.repositoryWrite.Save(shortURL, url, addedUserID.(string))

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entity.ShortURLEntity{ShortURL: shortURL, URL: url}, nil</span>
}

// Batch Массовое сохранение
func (service *ShortURLService) Batch(request []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        return service.repositoryWrite.Batch(request)
}</span>

// GetUrlsByUserID получение ссылок по пользователю
func (service *ShortURLService) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        return service.repositoryRead.GetUrlsByUserID(userID)
}</span>

// Delete удаление
func (service *ShortURLService) Delete(URLList []string, addedUserID string) <span class="cov8" title="1">{
        var chunk []string
        var chunks [][]string
        i := 0
        for _, URL := range URLList </span><span class="cov8" title="1">{
                chunk = append(chunk, URL)

                if i &lt; 10 </span><span class="cov8" title="1">{
                        i++
                }</span> else<span class="cov8" title="1"> {
                        chunks = append(chunks, chunk)
                        chunk = nil
                        i = 0
                }</span>

        }

        <span class="cov8" title="1">var deletedURLs []string
        if len(chunk) &gt; 0 </span><span class="cov8" title="1">{
                chunks = append(chunks, chunk)
                chunk = nil
        }</span>

        <span class="cov8" title="1">inCh := service.sendToPrepare(chunks)
        ch1 := service.prepareGoodURL(inCh, addedUserID)
        ch2 := service.prepareGoodURL(inCh, addedUserID)
        for n := range service.fanIn(ch1, ch2) </span><span class="cov8" title="1">{
                deletedURLs = append(deletedURLs, n...)
        }</span>

        <span class="cov8" title="1">service.notification(deletedURLs)</span>
}

// sendToPrepare отправляем в поток на обработку
func (service *ShortURLService) sendToPrepare(chunks [][]string) chan []string <span class="cov8" title="1">{
        outCh := make(chan []string)
        go func() </span><span class="cov8" title="1">{
                defer close(outCh)
                for _, chunk := range chunks </span><span class="cov8" title="1">{
                        outCh &lt;- chunk
                }</span>
        }()

        <span class="cov8" title="1">return outCh</span>
}

// Возвращаем только те URL, которые действо можно удалить
func (service *ShortURLService) prepareGoodURL(inCh chan []string, addedUserID string) chan []string <span class="cov8" title="1">{
        outCh := make(chan []string)

        go func() </span><span class="cov8" title="1">{
                defer close(outCh)
                for shortURLs := range inCh </span><span class="cov8" title="1">{
                        err := service.repositoryWrite.Delete(shortURLs, addedUserID)
                        if err != nil </span><span class="cov0" title="0">{
                                service.logger.Error("ошибка получения записей", zap.String("urls", strings.Join(shortURLs, ",")), zap.String("addedUserID", addedUserID), zap.Error(err))
                                return
                        }</span>

                        <span class="cov8" title="1">outCh &lt;- shortURLs</span>
                }
        }()

        <span class="cov8" title="1">return outCh</span>
}

// fanIn обработка потока
func (service *ShortURLService) fanIn(chs ...chan []string) chan []string <span class="cov8" title="1">{
        var wg sync.WaitGroup
        outCh := make(chan []string)

        // определяем функцию output для каждого канала в chs
        // функция output копирует значения из канала с в канал outCh, пока с не будет закрыт
        output := func(c chan []string) </span><span class="cov8" title="1">{
                for n := range c </span><span class="cov8" title="1">{
                        outCh &lt;- n
                }</span>
                <span class="cov8" title="1">wg.Done()</span>
        }

        // добавляем в группу столько горутин, сколько каналов пришло в fanIn
        <span class="cov8" title="1">wg.Add(len(chs))
        // перебираем все каналы, которые пришли и отправляем каждый в отдельную горутину
        for _, c := range chs </span><span class="cov8" title="1">{
                go output(c)
        }</span>

        // запускаем горутину для закрытия outCh после того, как все горутины отработают
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(outCh)
        }</span>()

        // возвращаем общий канал
        <span class="cov8" title="1">return outCh</span>
}

// notification уведомление о обработанных письмах
func (service *ShortURLService) notification(URLs []string) {<span class="cov8" title="1">
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package utils

import (
        "crypto/sha1"
        "encoding/base64"
)

// GenerateShortURL формированиерое краткого url
func GenerateShortURL(url string) string <span class="cov0" title="0">{
        hash := sha1.New()
        hash.Write([]byte(url))
        return base64.URLEncoding.EncodeToString(hash.Sum(nil))[:8]

}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package config

//  -a=http://localhost:8081/api/shorten -b=http://localhost:8081/api/shorten
import (
        "cmp"
        "flag"
        "fmt"
        "net/netip"
        "os"
        "strconv"
        "strings"
)

// Config структура
type Config struct {
        AddressStart AddressStartType
        BaseShort    BaseShortURLType
        FileStorage  FileStorageType
        DatabaseURL  DatabaseURLType
        StorageType  string
        FullLog      bool
}

// StorageTypeMemory место зранения
const StorageTypeMemory = "Memory"

// StorageTypeFile место зранения
const StorageTypeFile = "File"

// StorageTypeDB место зранения
const StorageTypeDB = "DB"

// FileStorageType стуктура
type FileStorageType struct {
        Path string
}

// AddressStartType стуктура
type AddressStartType struct {
        URL  string
        Port string
}

// BaseShortURLType стуктура
type BaseShortURLType struct {
        URL string
}

// DatabaseURLType стуктура
type DatabaseURLType struct {
        URL string
}

// NewConfig получение конфигов
func NewConfig() *Config <span class="cov8" title="1">{
        var ServerAddress AddressStartType
        var BaseURL BaseShortURLType
        var FileStorage FileStorageType
        var databaseURL DatabaseURLType

        flag.Var(&amp;ServerAddress, "a", "start url and port")
        flag.Var(&amp;BaseURL, "b", "url redirect")
        flag.Var(&amp;FileStorage, "f", "file storage path")
        flag.Var(&amp;databaseURL, "d", "database storage path")
        flag.Parse()
        var URL, port string
        data := strings.Split(cmp.Or(ServerAddress.String(), os.Getenv("SERVER_ADDRESS"), "localhost:8080"), ":")
        URL = data[0]
        port = data[1]

        BaseURLFinal := cmp.Or(BaseURL.String(), os.Getenv("BASE_URL"), "http://localhost:8080")
        FileStorageFinal := cmp.Or(FileStorage.String(), os.Getenv("FILE_STORAGE_PATH"), "/tmp/db.txt")
        databaseURLFinal := cmp.Or(databaseURL.String(), os.Getenv("DATABASE_DSN"), "postgres://postgres:postgres@localhost:5432/shorturl?sslmode=disable")

        var storageType = StorageTypeMemory

        if FileStorage.String() != "" || os.Getenv("FILE_STORAGE_PATH") != "" </span><span class="cov0" title="0">{
                storageType = StorageTypeFile
        }</span>

        <span class="cov8" title="1">if databaseURL.String() != "" || os.Getenv("DATABASE_DSN") != "" </span><span class="cov0" title="0">{
                storageType = StorageTypeDB
        }</span>

        <span class="cov8" title="1">return &amp;Config{
                AddressStart: AddressStartType{URL: URL, Port: port},
                BaseShort:    BaseShortURLType{URL: BaseURLFinal},
                FileStorage:  FileStorageType{Path: FileStorageFinal},
                DatabaseURL:  DatabaseURLType{URL: databaseURLFinal},
                StorageType:  storageType,
                FullLog:      false,
        }</span>
}

// String AddressStartType
func (d *AddressStartType) String() string <span class="cov8" title="1">{
        arr := make([]string, 0)
        arr = append(arr, d.URL, d.Port)

        if arr[0] != "" &amp;&amp; arr[1] != "" </span><span class="cov0" title="0">{
                return fmt.Sprint(strings.Join(arr, ":"))
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// Set AddressStartType
func (d *AddressStartType) Set(flagValue string) error <span class="cov0" title="0">{
        data := strings.Split(flagValue, ":")

        var ip string

        if data[0] == "localhost" </span><span class="cov0" title="0">{
                ip = data[0]
        }</span> else<span class="cov0" title="0"> {
                add, err := netip.ParseAddr(data[0])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">ip = add.String()</span>
        }

        <span class="cov0" title="0">port, err2 := strconv.Atoi(data[1])
        if err2 != nil </span><span class="cov0" title="0">{
                return err2
        }</span>

        <span class="cov0" title="0">if port &lt; 1 || port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("PORT incorrected")
        }</span>

        <span class="cov0" title="0">d.URL = ip
        d.Port = data[1]

        return nil</span>
}

// String BaseShortURLType
func (d *BaseShortURLType) String() string <span class="cov8" title="1">{
        return d.URL
}</span>

// Set BaseShortURLType
func (d *BaseShortURLType) Set(flagValue string) error <span class="cov0" title="0">{
        d.URL = flagValue

        return nil
}</span>

// String FileStorageType
func (d *FileStorageType) String() string <span class="cov8" title="1">{
        return d.Path
}</span>

// Set FileStorageType
func (d *FileStorageType) Set(flagValue string) error <span class="cov0" title="0">{
        d.Path = flagValue

        return nil
}</span>

// String DatabaseURLType
func (d *DatabaseURLType) String() string <span class="cov8" title="1">{
        return d.URL
}</span>

// Set DatabaseURLType
func (d *DatabaseURLType) Set(flagValue string) error <span class="cov0" title="0">{
        d.URL = flagValue

        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
