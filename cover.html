
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>shortener: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/arturturundaev/shorturl/cmd/shortener/main.go (40.2%)</option>
				
				<option value="file1">github.com/arturturundaev/shorturl/cmd/staticlint/linter.go (75.0%)</option>
				
				<option value="file2">github.com/arturturundaev/shorturl/internal/app/handler/batch/batch_handler.go (85.0%)</option>
				
				<option value="file3">github.com/arturturundaev/shorturl/internal/app/handler/batch/batch_request.go (83.3%)</option>
				
				<option value="file4">github.com/arturturundaev/shorturl/internal/app/handler/delete/delete_handler.go (87.5%)</option>
				
				<option value="file5">github.com/arturturundaev/shorturl/internal/app/handler/find/find_handler.go (100.0%)</option>
				
				<option value="file6">github.com/arturturundaev/shorturl/internal/app/handler/ping/ping_handler.go (88.9%)</option>
				
				<option value="file7">github.com/arturturundaev/shorturl/internal/app/handler/save/save_handler.go (82.4%)</option>
				
				<option value="file8">github.com/arturturundaev/shorturl/internal/app/handler/shorten/shorten_handler.go (100.0%)</option>
				
				<option value="file9">github.com/arturturundaev/shorturl/internal/app/handler/shorten/shorten_request.go (100.0%)</option>
				
				<option value="file10">github.com/arturturundaev/shorturl/internal/app/handler/user/url_handler.go (92.9%)</option>
				
				<option value="file11">github.com/arturturundaev/shorturl/internal/app/handler/user/url_list_response.go (100.0%)</option>
				
				<option value="file12">github.com/arturturundaev/shorturl/internal/app/middleware/jwt.go (86.5%)</option>
				
				<option value="file13">github.com/arturturundaev/shorturl/internal/app/repository/filestorage/file_storage_repository.go (81.0%)</option>
				
				<option value="file14">github.com/arturturundaev/shorturl/internal/app/repository/localstorage/local_storage_repository.go (90.6%)</option>
				
				<option value="file15">github.com/arturturundaev/shorturl/internal/app/repository/postgres/postgres.go (48.4%)</option>
				
				<option value="file16">github.com/arturturundaev/shorturl/internal/app/service/ping_service.go (50.0%)</option>
				
				<option value="file17">github.com/arturturundaev/shorturl/internal/app/service/short_url_service.go (71.2%)</option>
				
				<option value="file18">github.com/arturturundaev/shorturl/internal/app/utils/short_url_generator.go (100.0%)</option>
				
				<option value="file19">github.com/arturturundaev/shorturl/internal/config/config.go (46.3%)</option>
				
				<option value="file20">github.com/arturturundaev/shorturl/internal/pkg/analyser/exitmain/exitmain.go (91.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "context"
        "fmt"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        deleteUrl "github.com/arturturundaev/shorturl/internal/app/handler/delete"
        "github.com/arturturundaev/shorturl/internal/app/handler/find"
        "github.com/arturturundaev/shorturl/internal/app/handler/ping"
        "github.com/arturturundaev/shorturl/internal/app/handler/save"
        "github.com/arturturundaev/shorturl/internal/app/handler/shorten"
        "github.com/arturturundaev/shorturl/internal/app/handler/user"
        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/arturturundaev/shorturl/internal/app/repository/filestorage"
        "github.com/arturturundaev/shorturl/internal/app/repository/localstorage"
        pg "github.com/arturturundaev/shorturl/internal/app/repository/postgres"
        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/arturturundaev/shorturl/internal/config"
        "github.com/gin-contrib/gzip"
        "github.com/gin-contrib/pprof"
        ginzap "github.com/gin-contrib/zap"
        "github.com/gin-gonic/gin"
        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/pgx/v5"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/jmoiron/sqlx"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "io"
        "log"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"
)

// Build variables
var (
        // BuildVersion - version
        BuildVersion string = "N/A"
        // BuildDate - date
        BuildDate string = "N/A"
        // BuildCommit - commit
        BuildCommit string = "N/A"
)

// -d=postgres://postgres:postgres@localhost:5432/shorturl?sslmode=disable
// SaveFullURL создание
const SaveFullURL = `/`

// GetFullURL получение
const GetFullURL = `/:short`

// SaveFullURL2 v2
const SaveFullURL2 = `/api/shorten`

// SaveBatch массовое сохранение
const SaveBatch = `/api/shorten/batch`

// Ping пинг
const Ping = `/ping`

// URLByUser получение по пользователю
const URLByUser = `/api/user/urls`

// DeleteByUrls удаление ссылок
const DeleteByUrls = `/api/user/urls`

func main() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        log.Println("panic occurred:", err)
                }</span>
        }()

        <span class="cov0" title="0">router, logger, serverConfig, repoRW := initRouter()

        logger.Info(fmt.Sprintf("Build version: %s\n", BuildVersion))
        logger.Info(fmt.Sprintf("Build date: %s\n", BuildDate))
        logger.Info(fmt.Sprintf("Build commit: %s\n", BuildCommit))

        logger.Info("server start on port: " + serverConfig.AddressStart)

        server := &amp;http.Server{
                Addr:    serverConfig.AddressStart,
                Handler: router,
        }

        go func() </span><span class="cov0" title="0">{
                var errServer error
                if serverConfig.HTTPS.Enabled </span><span class="cov0" title="0">{
                        errServer = server.ListenAndServeTLS(serverConfig.HTTPS.SSLPemPath, serverConfig.HTTPS.SSLKeyPath)
                }</span> else<span class="cov0" title="0"> {
                        errServer = server.ListenAndServe()
                }</span>
                <span class="cov0" title="0">if errServer != nil </span><span class="cov0" title="0">{
                        logger.Fatal(errServer.Error())
                }</span>
        }()

        <span class="cov0" title="0">signalChan := make(chan os.Signal, 1)
        signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
        sig := &lt;-signalChan
        logger.Error(fmt.Sprintf("Shutdown server: %v...", sig))
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error(fmt.Sprintf("HTTP server Shutdown error: %v\n", err))
        }</span>
        // Если храним всё в памяти - сохраним всё в файл
        <span class="cov0" title="0">if serverConfig.StorageType == config.StorageTypeMemory </span><span class="cov0" title="0">{
                err := repoRW.(*localstorage.LocalStorageRepository).SaveToFile("/tmp/save.txt")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err.Error())
                }</span>
        }

        <span class="cov0" title="0">logger.Info("Server exited")</span>
}

func initRouter() (*gin.Engine, *zap.Logger, *config.Config, service.RepositoryWriter) <span class="cov8" title="1">{

        router := gin.Default()

        router.Use(gzip.Gzip(gzip.DefaultCompression, gzip.WithDecompressFn(gzip.DefaultDecompressHandle)))

        serverConfig := config.NewConfig()

        logger, err := addLogger(router, serverConfig.FullLog)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err.Error())
                os.Exit(5)
        }</span>

        <span class="cov8" title="1">repositoryRead, repositoryWrite := getRepository(serverConfig, logger)

        if repositoryRead == nil </span><span class="cov0" title="0">{
                logger.Error("ошибка инициализации репозитория на чтение. Тип репозитория: " + config.StorageTypeDB)
        }</span>

        <span class="cov8" title="1">if repositoryWrite == nil </span><span class="cov0" title="0">{
                logger.Error("ошибка инициализации репозитория на запись. Тип репозитория: " + config.StorageTypeDB)
        }</span>

        <span class="cov8" title="1">if serverConfig.StorageType == config.StorageTypeDB </span><span class="cov0" title="0">{
                absPath, errPathMigration := filepath.Abs(".")
                if errPathMigration != nil </span><span class="cov0" title="0">{
                        logger.Error("ошибка определения директории для миграций!")
                }</span> else<span class="cov0" title="0"> {
                        initMigrations("file:////"+absPath+"/internal/app/repository/postgres/migration", repositoryRead.GetDB())
                }</span>
        }

        <span class="cov8" title="1">jwtValidate := middleware.NewJWTValidator(serverConfig.AddressStart)

        shortURLService := service.NewShortURLService(repositoryRead, repositoryWrite)

        pingService := service.NewPingService(repositoryRead)

        handlerFind := find.NewFindHandler(shortURLService)
        handlerSave := save.NewSaveHandler(shortURLService, serverConfig.BaseShort)
        handlerSave2 := shorten.NewShortenHandler(shortURLService, serverConfig.BaseShort)
        handlerPing := ping.NewPingHandler(pingService)
        handlerButch := batch.NewButchHandler(shortURLService, serverConfig.BaseShort)
        handlerFindByUser := user.NewURLFindByUserHandler(shortURLService, serverConfig.BaseShort)
        handlerDelete := deleteUrl.NewDeleteHandler(shortURLService)

        router.GET(Ping, handlerPing.Handle)
        router.POST(SaveFullURL, jwtValidate.Handle, handlerSave.Handle)
        router.GET(GetFullURL, handlerFind.Handle)
        router.POST(SaveFullURL2, jwtValidate.Handle, handlerSave2.Handle)
        router.POST(SaveBatch, handlerButch.Handle)
        router.GET(URLByUser, jwtValidate.Handle, handlerFindByUser.Handle)
        router.DELETE(DeleteByUrls, jwtValidate.Handle, handlerDelete.Handle)

        pprof.Register(router, "dev/pprof")

        return router, logger, serverConfig, repositoryWrite</span>

}

func addLogger(r *gin.Engine, fullLogger bool) (*zap.Logger, error) <span class="cov8" title="1">{
        logger, err := zap.NewProduction()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if fullLogger </span><span class="cov8" title="1">{
                r.Use(ginzap.Ginzap(logger, time.RFC3339, true))
                r.Use(ginzap.RecoveryWithZap(logger, true))
                r.Use(ginzap.GinzapWithConfig(logger, &amp;ginzap.Config{
                        UTC:        true,
                        TimeFormat: time.RFC3339,
                        Context: ginzap.Fn(func(c *gin.Context) []zapcore.Field </span><span class="cov0" title="0">{
                                var fields []zapcore.Field
                                // log request ID
                                if requestID := c.Writer.Header().Get("X-Request-Id"); requestID != "" </span><span class="cov0" title="0">{
                                        fields = append(fields, zap.String("request_id", requestID))
                                }</span>

                                // log request body
                                <span class="cov0" title="0">var body []byte
                                var buf bytes.Buffer
                                tee := io.TeeReader(c.Request.Body, &amp;buf)
                                body, _ = io.ReadAll(tee)
                                c.Request.Body = io.NopCloser(&amp;buf)
                                fields = append(fields, zap.String("body", string(body)))

                                return fields</span>
                        }),
                }))
        }

        <span class="cov8" title="1">return logger, nil</span>
}

func initMigrations(migrationPath string, DB *sqlx.DB) <span class="cov0" title="0">{
        driver, err := postgres.WithInstance(DB.DB, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                migrationPath,
                "postgres", driver)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span> else<span class="cov0" title="0"> {
                errMigrate := m.Up()
                if errMigrate != nil &amp;&amp; errMigrate.Error() != "no change" </span><span class="cov0" title="0">{
                        log.Fatal(errMigrate)
                }</span>
        }
}

func getRepository(serverConfig *config.Config, logger *zap.Logger) (service.RepositoryReader, service.RepositoryWriter) <span class="cov8" title="1">{

        if serverConfig.StorageType == config.StorageTypeDB </span><span class="cov0" title="0">{
                database, err := sqlx.Open("postgres", serverConfig.DatabaseURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">repository, errPingRepo := pg.NewPostgresRepository(database)
                if errPingRepo != nil </span><span class="cov0" title="0">{
                        logger.Error(errPingRepo.Error())
                }</span>

                <span class="cov0" title="0">return repository, repository</span>
        }

        <span class="cov8" title="1">if serverConfig.StorageType == config.StorageTypeFile </span><span class="cov8" title="1">{
                repositoryWrite, errStorageWrite := filestorage.NewFileStorageRepositoryWrite(serverConfig.FileStorage)
                if errStorageWrite != nil </span><span class="cov0" title="0">{
                        logger.Error(errStorageWrite.Error())
                }</span>

                <span class="cov8" title="1">repositoryRead, errStorageRead := filestorage.NewFileStorageRepositoryRead(serverConfig.FileStorage)
                if errStorageRead != nil </span><span class="cov0" title="0">{
                        logger.Error(errStorageRead.Error())
                }</span>

                <span class="cov8" title="1">return repositoryRead, repositoryWrite</span>
        }

        <span class="cov8" title="1">if serverConfig.StorageType == config.StorageTypeMemory </span><span class="cov8" title="1">{
                repositoryWrite := localstorage.NewLocalStorageRepository()

                return repositoryWrite, repositoryWrite
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package staticlint

import (
        "github.com/arturturundaev/shorturl/internal/pkg/analyser/exitmain"
        "github.com/gordonklaus/ineffassign/pkg/ineffassign"
        "github.com/timakin/bodyclose/passes/bodyclose"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/appends"
        "golang.org/x/tools/go/analysis/passes/errorsas"
        "golang.org/x/tools/go/analysis/passes/httpresponse"
        "golang.org/x/tools/go/analysis/passes/lostcancel"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "golang.org/x/tools/go/analysis/passes/testinggoroutine"
        "golang.org/x/tools/go/analysis/passes/unmarshal"
        "golang.org/x/tools/go/analysis/passes/unreachable"
        "honnef.co/go/tools/quickfix/qf1001"
        "honnef.co/go/tools/simple"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck/st1001"
)

func main() <span class="cov0" title="0">{
        checks := getChecks()

        multichecker.Main(
                checks...,
        )
}</span>

func getChecks() []*analysis.Analyzer <span class="cov8" title="1">{
        checks := []*analysis.Analyzer{
                // check consistency of Printf format strings and arguments
                printf.Analyzer,
                // check for possible unintended shadowing of variables
                shadow.Analyzer,
                // check that struct field tags
                structtag.Analyzer,
                // checks for unreachable code
                unreachable.Analyzer,
                // report passing non-pointer or non-interface values to unmarshal
                unmarshal.Analyzer,
                // report calls to (*testing.T).Fatal from goroutines started by a test
                testinggoroutine.Analyzer,
                // check cancel func returned by context.WithCancel is called
                lostcancel.Analyzer,
                // check for mistakes using HTTP responses
                httpresponse.Analyzer,
                errorsas.Analyzer,
                // report passing non-pointer or non-error values to errors.As
                appends.Analyzer,
                // dot imports are discouraged
                st1001.Analyzer,
                // Apply De Morgan's law
                qf1001.Analyzer,
                // detect ineffectual assignments in Go code
                ineffassign.Analyzer,
                // checks whether HTTP response body is closed successfully
                bodyclose.Analyzer,
                // Checking the use of a direct call to os.Exit in the main function of the main package
                exitmain.Analyzer,
        }

        for _, v := range staticcheck.Analyzers </span><span class="cov8" title="1">{
                checks = append(checks, v.Analyzer)
        }</span>

        <span class="cov8" title="1">for _, v := range simple.Analyzers </span><span class="cov8" title="1">{
                checks = append(checks, v.Analyzer)
        }</span>

        <span class="cov8" title="1">return checks</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package batch

import (
        "encoding/json"
        "fmt"
        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/gin-gonic/gin"
        "net/http"
)

type serviceURLButcher interface {
        Batch(request []ButchRequest) ([]entity.ShortURLEntity, error)
}

// ButchHandler ButchHandler
type ButchHandler struct {
        service serviceURLButcher
        baseURL string
}

// NewButchHandler конструктор
func NewButchHandler(service serviceURLButcher, baseURL string) *ButchHandler <span class="cov0" title="0">{
        return &amp;ButchHandler{service: service, baseURL: baseURL}
}</span>

// Handle массовоt создание
func (h *ButchHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        var response []ButchResponse
        request, err := NewButchRequest(ctx)
        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">models, err := h.service.Batch(request)
        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">for _, model := range models </span><span class="cov8" title="1">{
                response = append(response, ButchResponse{CorrelationID: model.CorrelationID, ShortURL: fmt.Sprintf("%s/%s", h.baseURL, model.ShortURL)})
        }</span>

        <span class="cov8" title="1">bt, errMarshal := json.Marshal(response)

        if errMarshal != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": errMarshal.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.Writer.Header().Set("Accept-Encoding", "gzip")
        ctx.Writer.Header().Set("Content-Encoding", "gzip")
        ctx.Writer.Header().Set("Content-Type", "application/json")
        ctx.Data(http.StatusCreated, "gzip", bt)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package batch

import (
        "fmt"

        "github.com/gin-gonic/gin"
)

// ButchRequest dto
type ButchRequest struct {
        CorrelationID string `json:"correlation_id"`
        OriginalURL   string `json:"original_url"`
}

// NewButchRequest конструктор
func NewButchRequest(context *gin.Context) ([]ButchRequest, error) <span class="cov8" title="1">{
        var dto []ButchRequest

        if err := context.BindJSON(&amp;dto); err != nil </span><span class="cov8" title="1">{
                return dto, err
        }</span>

        <span class="cov8" title="1">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("пустой входной массив")
        }</span>

        <span class="cov8" title="1">return dto, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package delete

import (
        "encoding/json"
        "io"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/gin-gonic/gin"
)

type deleter interface {
        Delete(URLList []string, addedUserID string)
}

// DeleteHandler сервис
type DeleteHandler struct {
        service deleter
}

// NewDeleteHandler конструктор
func NewDeleteHandler(service deleter) *DeleteHandler <span class="cov8" title="1">{
        return &amp;DeleteHandler{service: service}
}</span>

// Handle обработчик удаления
func (h *DeleteHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        var data []string
        body, err := io.ReadAll(ctx.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(body, &amp;data)
        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov8" title="1">addedUserID, exists := ctx.Get(middleware.UserIDProperty)

        if !exists </span><span class="cov8" title="1">{
                ctx.Status(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">go h.service.Delete(data, addedUserID.(string))

        ctx.Status(http.StatusAccepted)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package find

import (
        "fmt"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/gin-gonic/gin"
)

// FindHandler сервис
type FindHandler struct {
        service *service.ShortURLService
}

// NewFindHandler конструктор
func NewFindHandler(service *service.ShortURLService) *FindHandler <span class="cov8" title="1">{
        return &amp;FindHandler{service: service}
}</span>

// Handle обработчик поиска
func (hndlr *FindHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{

        data, err := hndlr.service.FindByShortURL(ctx.Param("short"))

        if err != nil || data == nil </span><span class="cov8" title="1">{
                er := err
                if data == nil </span><span class="cov8" title="1">{
                        er = fmt.Errorf("not find")
                }</span>
                <span class="cov8" title="1">ctx.String(http.StatusBadRequest, "%s", er.Error())
                ctx.Abort()
                return</span>
        }

        <span class="cov8" title="1">if data.IsDeleted </span><span class="cov8" title="1">{
                ctx.Status(http.StatusGone)
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">ctx.Redirect(http.StatusTemporaryRedirect, data.URL)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package ping

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

type pignger interface {
        Ping(ctx context.Context) error
}

// PingHandler сервис
type PingHandler struct {
        service pignger
}

// NewPingHandler конструктор
func NewPingHandler(service pignger) *PingHandler <span class="cov0" title="0">{
        return &amp;PingHandler{service: service}
}</span>

// Handle обработчик поиска
func (h *PingHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{

        contxt, cancel := context.WithCancel(ctx)
        defer cancel()
        time.AfterFunc(1500*time.Millisecond, cancel)

        err := h.service.Ping(contxt)

        if err != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.AbortWithStatusJSON(http.StatusOK, "")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package save

import (
        "errors"
        "io"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/gin-gonic/gin"
)

// SaveHandler сервис
type SaveHandler struct {
        service *service.ShortURLService
        baseURL string
}

// NewSaveHandler конструктор
func NewSaveHandler(service *service.ShortURLService, baseURL string) *SaveHandler <span class="cov8" title="1">{
        return &amp;SaveHandler{service: service, baseURL: baseURL}
}</span>

// Handle обработчик сохранения
func (hndlr *SaveHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        b, err := io.ReadAll(ctx.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">data, err := hndlr.service.Save(ctx, string(b))

        if errors.Is(err, service.ErrEntityExists) </span><span class="cov8" title="1">{
                ctx.Header("Content-type", "text/plain")
                ctx.String(http.StatusConflict, "%s/%s", hndlr.baseURL, data.ShortURL)
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">ctx.Header("Content-type", "text/plain")
        ctx.String(http.StatusCreated, "%s/%s", hndlr.baseURL, data.ShortURL)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package shorten

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/gin-gonic/gin"
)

// Handle интерфейс для сохранения
type URLSaver interface {
        Save(ctx *gin.Context, url string) (*entity.ShortURLEntity, error)
}

// Handle сервис
type ShortenHandler struct {
        service URLSaver
        baseURL string
}

// Handle конструктор
func NewShortenHandler(service URLSaver, baseURL string) *ShortenHandler <span class="cov8" title="1">{
        return &amp;ShortenHandler{service: service, baseURL: baseURL}
}</span>

// Handle обаботчик
func (h *ShortenHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        dto, errGenerateShortURL := NewShortenRequest(ctx)

        if errGenerateShortURL != nil </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": errGenerateShortURL.Error()})
                return
        }</span>

        <span class="cov8" title="1">data, errRepository := h.service.Save(ctx, dto.URL)

        if errRepository != nil &amp;&amp; !errors.Is(errRepository, service.ErrEntityExists) </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": errRepository.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := ShortenResponse{URL: fmt.Sprintf("%s/%s", h.baseURL, data.ShortURL)}

        status := http.StatusCreated

        if errors.Is(errRepository, service.ErrEntityExists) </span><span class="cov8" title="1">{
                status = http.StatusConflict
        }</span>

        <span class="cov8" title="1">ctx.JSON(status, response)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package shorten

import (
        "github.com/gin-gonic/gin"
)

// ShortenRequest dto
type ShortenRequest struct {
        URL string `json:"url" binding:"required"`
}

// NewShortenRequest конструктор
func NewShortenRequest(context *gin.Context) (*ShortenRequest, error) <span class="cov8" title="1">{
        dto := &amp;ShortenRequest{}

        if err := context.BindJSON(dto); err != nil </span><span class="cov8" title="1">{
                return dto, err
        }</span>

        <span class="cov8" title="1">return dto, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package user

import (
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/gin-gonic/gin"
)

// Handle интерфейс поиска ссылок по пользователю
type URLServiceFinder interface {
        GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error)
}

// Handle сервис
type URLFindByUserHandler struct {
        service URLServiceFinder
        baseURL string
}

// Handle конструктор
func NewURLFindByUserHandler(service URLServiceFinder, baseURL string) *URLFindByUserHandler <span class="cov0" title="0">{
        return &amp;URLFindByUserHandler{service: service, baseURL: baseURL}
}</span>

// Handle обработчик
func (handler *URLFindByUserHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        addedUserID, _ := ctx.Get(middleware.UserIDProperty)

        data, err := handler.service.GetUrlsByUserID(addedUserID.(string))

        if err != nil </span><span class="cov8" title="1">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">if len(data) == 0 </span><span class="cov8" title="1">{
                ctx.Status(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">var response []URLListItemResponse

        for _, url := range data </span><span class="cov8" title="1">{
                response = append(response, NewURLResponse(handler.baseURL, url.ShortURL, url.URL))
        }</span>
        <span class="cov8" title="1">ctx.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package user

import "fmt"

// URLListItemResponse dto
type URLListItemResponse struct {
        ShortURL  string `json:"short_url"`
        OriginURL string `json:"original_url"`
}

// NewURLResponse конструктор
func NewURLResponse(baseURL, shortURL, originURL string) URLListItemResponse <span class="cov8" title="1">{
        return URLListItemResponse{OriginURL: originURL, ShortURL: fmt.Sprintf("%s/%s", baseURL, shortURL)}
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// JWTValidator сервис
type JWTValidator struct {
        Claims Claims
        domain string
}

// Claims структура
type Claims struct {
        jwt.RegisteredClaims
        UserID string
}

// TokenExp время жизни токена
const TokenExp = 3 * time.Hour

// SecretKey ключ шифрования
const SecretKey = "0N#6Ke|+OR:(`G;"

// UserIDProperty в каком поле храниться ID пользователя
const UserIDProperty = "UserId"

// NewJWTValidator конструктор
func NewJWTValidator(domain string) *JWTValidator <span class="cov8" title="1">{
        return &amp;JWTValidator{domain: domain}
}</span>

// Handle обработка проверки токена
func (JWTValidator *JWTValidator) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        var err error
        token, _ := ctx.Cookie("Authorization")

        if token == "" </span><span class="cov8" title="1">{
                token, err = JWTValidator.BuildJWTString(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(http.StatusForbidden, err)
                }</span>
        } else<span class="cov8" title="1"> {
                errorValidateToken := JWTValidator.ValidateJWT(ctx, token)
                if errorValidateToken != nil </span><span class="cov8" title="1">{
                        token, err = JWTValidator.BuildJWTString(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                ctx.AbortWithStatusJSON(http.StatusForbidden, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">claims := &amp;Claims{}
        // парсим из строки токена tokenString в структуру claims
        jwt.ParseWithClaims(token, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(SecretKey), nil
        }</span>)

        <span class="cov8" title="1">ctx.Set(UserIDProperty, claims.UserID)
        ctx.Header("Authorization", token)

        ctx.SetCookie("Authorization", token, 100000, "*", JWTValidator.domain, false, true)</span>

}

// ValidateJWT проверка токена
func (JWTValidator *JWTValidator) ValidateJWT(ctx *gin.Context, tokenString string) error <span class="cov8" title="1">{
        claims := &amp;Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims,
                func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov8" title="1">return []byte(SecretKey), nil</span>
                })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return fmt.Errorf("token is not valid")
        }</span>

        <span class="cov8" title="1">ctx.Set(UserIDProperty, claims.UserID)

        return nil</span>
}

// BuildJWTString формирование токена
func (JWTValidator *JWTValidator) BuildJWTString(ctx *gin.Context) (string, error) <span class="cov8" title="1">{
        userID := JWTValidator.getNewUserID()
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(TokenExp)),
                },
                UserID: userID,
        })

        tokenString, err := token.SignedString([]byte(SecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">ctx.Set(UserIDProperty, userID)

        return tokenString, nil</span>
}

func (JWTValidator *JWTValidator) getNewUserID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package filestorage

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/jmoiron/sqlx"
)

// FileStorageReadRepository сервис
type FileStorageReadRepository struct {
        file *os.File
}

// Find поиск
func (repo *FileStorageReadRepository) Find(shortURLs []string, addedUserID string) ([]entity.ShortURLEntity, error) <span class="cov8" title="1">{
        return make([]entity.ShortURLEntity, 0), nil
}</span>

// GetUrlsByUserID получение ссылок по пользователю
func (repo *FileStorageReadRepository) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov8" title="1">{
        var models []entity.ShortURLEntity

        return models, nil
}</span>

// GetDB получение коннекта к репозиторию на чтение
func (repo *FileStorageReadRepository) GetDB() *sqlx.DB <span class="cov8" title="1">{
        return nil
}</span>

// GetDB получение коннекта к репозиторию на запись
func (repo *FileStorageWriteRepository) GetDB() *sqlx.DB <span class="cov8" title="1">{
        return nil
}</span>

// Ping  пинг
func (repo *FileStorageReadRepository) Ping(ctx context.Context) error <span class="cov8" title="1">{
        return nil
}</span>

// FileStorageWriteRepository сервис
type FileStorageWriteRepository struct {
        file *os.File
}

// Batch Массовое сохранение
func (repo *FileStorageWriteRepository) Batch(ents []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov8" title="1">{
        var models []entity.ShortURLEntity
        var shortURL string
        for _, ent := range ents </span><span class="cov8" title="1">{
                shortURL = utils.GenerateShortURL(ent.OriginalURL)
                _, err := repo.file.WriteString(fmt.Sprintf(`{"short_url":"%s","original_url":"%s", "correlation_id":"%s"}`+"\n", shortURL, ent.OriginalURL, ent.CorrelationID))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">models = append(models, entity.ShortURLEntity{ShortURL: shortURL, URL: ent.OriginalURL, CorrelationID: ent.CorrelationID})</span>
        }

        <span class="cov8" title="1">return models, nil</span>
}

// NewFileStorageRepositoryWrite контсруктор на запись
func NewFileStorageRepositoryWrite(path string) (*FileStorageWriteRepository, error) <span class="cov8" title="1">{
        file, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;FileStorageWriteRepository{file: file}, nil</span>
}

// NewFileStorageRepositoryRead контсруктор на чтение
func NewFileStorageRepositoryRead(path string) (*FileStorageReadRepository, error) <span class="cov8" title="1">{
        file, err := os.OpenFile(path, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;FileStorageReadRepository{file: file}, nil</span>
}

// FindByShortURL поиск по короткой ссылке
func (repo *FileStorageReadRepository) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov8" title="1">{
        var dto entity.ShortURLEntity

        _, err := repo.file.Seek(0, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">scanner := bufio.NewScanner(repo.file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                if strings.Contains(scanner.Text(), shortURL) </span><span class="cov8" title="1">{
                        err := json.Unmarshal(scanner.Bytes(), &amp;dto)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">return &amp;dto, nil</span>
                }
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}

// Save сохранение
func (repo *FileStorageWriteRepository) Save(shortURL, URL, addedUserID string) error <span class="cov8" title="1">{
        _, err := repo.file.WriteString(fmt.Sprintf(`{"short_url":"%s","original_url":"%s", "added_user_id":"%s"}`+"\n", shortURL, URL, addedUserID))

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete удаление
func (repo *FileStorageWriteRepository) Delete(shortURLs []string, addedUserID string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package localstorage

import (
        "bufio"
        "context"
        "encoding/json"
        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/jmoiron/sqlx"
        "os"
)

// LocalStorageRepository сервис
type LocalStorageRepository struct {
        Rows map[string]LocalStorageRow
}

// GetUrlsByUserID получение ссылок по пользователю
func (repo *LocalStorageRepository) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov8" title="1">{
        var models []entity.ShortURLEntity
        return models, nil
}</span>

// LocalStorageRow сервис
type LocalStorageRow struct {
        ShortURL      string
        URL           string
        CorrelationID string
        AddedUserID   string
}

// Batch Массовое сохранение
func (repo *LocalStorageRepository) Batch(ents []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov8" title="1">{
        var shortURL string
        var models []entity.ShortURLEntity
        for _, ent := range ents </span><span class="cov8" title="1">{
                shortURL = utils.GenerateShortURL(ent.OriginalURL)
                repo.Rows[shortURL] = LocalStorageRow{ShortURL: shortURL, URL: ent.OriginalURL, CorrelationID: ent.CorrelationID}
                models = append(models, entity.ShortURLEntity{ShortURL: shortURL, URL: ent.OriginalURL, CorrelationID: ent.CorrelationID})
        }</span>

        <span class="cov8" title="1">return models, nil</span>
}

// NewLocalStorageRepository конструктор
func NewLocalStorageRepository() *LocalStorageRepository <span class="cov8" title="1">{
        return &amp;LocalStorageRepository{
                Rows: make(map[string]LocalStorageRow),
        }
}</span>

// FindByShortURL поиск по короткой ссылке
func (repo *LocalStorageRepository) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov8" title="1">{
        if row, exists := repo.Rows[shortURL]; exists </span><span class="cov8" title="1">{
                return &amp;(entity.ShortURLEntity{ShortURL: row.ShortURL, URL: row.URL, CorrelationID: row.CorrelationID}), nil
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}

// Save сохранение
func (repo *LocalStorageRepository) Save(shortURL, URL, addedUserID string) error <span class="cov8" title="1">{
        repo.Rows[shortURL] = LocalStorageRow{ShortURL: shortURL, URL: URL, AddedUserID: addedUserID}

        return nil
}</span>

// Ping  пинг
func (repo *LocalStorageRepository) Ping(ctx context.Context) error <span class="cov8" title="1">{

        return nil
}</span>

// GetDB получение коннекта к репозиторию
func (repo *LocalStorageRepository) GetDB() *sqlx.DB <span class="cov8" title="1">{
        return nil
}</span>

// Delete удаление
func (repo *LocalStorageRepository) Delete(shortURLs []string, addedUserID string) error <span class="cov8" title="1">{
        return nil
}</span>

func (repo *LocalStorageRepository) SaveToFile(fileName string) error <span class="cov8" title="1">{
        file, err := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        writer := bufio.NewWriter(file)
        encoder := json.NewEncoder(writer)
        for _, v := range repo.Rows </span><span class="cov8" title="1">{
                err = encoder.Encode(v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">err = writer.Flush()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package postgres

import (
        "context"
        "fmt"
        "strings"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// TableName имя таблицы
const TableName = "url"

// Количество записей на одну вставвку
const ButchSize = 100

// PostgresRepository сервис
type PostgresRepository struct {
        DB *sqlx.DB
}

// NewPostgresRepository конструктор
func NewPostgresRepository(DB *sqlx.DB) (*PostgresRepository, error) <span class="cov0" title="0">{
        return &amp;PostgresRepository{DB: DB}, nil
}</span>

// Ping  пинг
func (repo *PostgresRepository) Ping(ctx context.Context) error <span class="cov8" title="1">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("прервали работу")</span>
        default:<span class="cov8" title="1">
                return repo.DB.Ping()</span>
        }
}

// FindByShortURL поиск по короткой ссылке
func (repo *PostgresRepository) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov8" title="1">{

        ent := []entity.ShortURLEntity{}
        err := repo.DB.Select(&amp;ent,
                fmt.Sprintf("select url_full as original_url, url_short, is_deleted from %s where url_short = $1", TableName),
                shortURL)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(ent) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return &amp;ent[0], nil</span>
}

// Save сохранение
func (repo *PostgresRepository) Save(shortURL, URL, addedUserID string) error <span class="cov0" title="0">{

        id := uuid.New().String()
        _, err := repo.DB.Exec(fmt.Sprintf(`INSERT into %s (id, url_full, url_short, added_user_id) values ($1, $2, $3, $4)`, TableName), id, URL, shortURL, addedUserID)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDB получение коннекта к репозиторию
func (repo *PostgresRepository) GetDB() *sqlx.DB <span class="cov0" title="0">{
        return repo.DB
}</span>

// Batch Массовое сохранение
func (repo *PostgresRepository) Batch(request []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov8" title="1">{
        var models []entity.ShortURLEntity
        var allModels []entity.ShortURLEntity

        tx, err := repo.DB.Begin()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">k := 0
        var values []string
        var params []interface{}

        for i, item := range request </span><span class="cov8" title="1">{
                models = append(models, entity.ShortURLEntity{URL: item.OriginalURL, CorrelationID: item.CorrelationID, ShortURL: utils.GenerateShortURL(item.OriginalURL)})

                if len(models) == ButchSize || len(request) == i+1 </span><span class="cov8" title="1">{
                        values = nil
                        params = nil
                        for _, enty := range models </span><span class="cov8" title="1">{
                                values = append(values, "("+
                                        "$"+fmt.Sprintf("%d,", k+1)+
                                        "$"+fmt.Sprintf("%d,", k+2)+
                                        "$"+fmt.Sprintf("%d,", k+3)+
                                        "$"+fmt.Sprintf("%d", k+4)+")")
                                params = append(params, uuid.New().String(), enty.URL, enty.ShortURL, enty.CorrelationID)
                                k += 4
                        }</span>

                        <span class="cov8" title="1">valuesStr := strings.Join(values, ",")
                        _, err = repo.DB.Exec(fmt.Sprintf(`INSERT into %s values %s`, TableName, valuesStr), params...)
                        if err != nil </span><span class="cov0" title="0">{
                                err2 := tx.Rollback()
                                if err2 != nil </span><span class="cov0" title="0">{
                                        return nil, err2
                                }</span>
                                <span class="cov0" title="0">return nil, err</span>
                        }
                        <span class="cov8" title="1">allModels = append(allModels, models...)
                        models = nil</span>
                }
        }

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return allModels, nil</span>
}

// GetUrlsByUserID получение ссылок по пользователю
func (repo *PostgresRepository) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        ent := []entity.ShortURLEntity{}

        err := repo.DB.Select(&amp;ent,
                fmt.Sprintf("select url_full as original_url, url_short from %s where added_user_id = $1", TableName),
                userID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ent, nil</span>
}

// Delete удаление
func (repo *PostgresRepository) Delete(shortURLs []string, addedUserID string) error <span class="cov0" title="0">{
        var inArray []string
        var params []interface{}

        params = append(params, addedUserID)
        i := 2
        for _, shortURL := range shortURLs </span><span class="cov0" title="0">{
                inArray = append(inArray, "$"+fmt.Sprintf("%d", i))
                params = append(params, shortURL)
                i++
        }</span>
        <span class="cov0" title="0">_, err := repo.DB.Exec(fmt.Sprintf(`update %s SET is_deleted = true WHERE added_user_id = $1 AND url_short IN (%s)`, TableName, strings.Join(inArray, ",")), params...)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package service

import "context"

// PingService сервис
type PingService struct {
        repository RepositoryReader
}

// NewPingService Конструктор
func NewPingService(repository RepositoryReader) *PingService <span class="cov8" title="1">{
        return &amp;PingService{repository: repository}
}</span>

// Ping пиннг
func (s *PingService) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return s.repository.Ping(ctx)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// ShortURLService сервис
type ShortURLService struct {
        repositoryRead  RepositoryReader
        repositoryWrite RepositoryWriter
        logger          *zap.Logger
}

// ErrEntityExists ошибка нет записи
var ErrEntityExists = errors.New("entity exists")

// NewShortURLService конструктор
func NewShortURLService(repositoryRead RepositoryReader, repositoryWrite RepositoryWriter) *ShortURLService <span class="cov0" title="0">{
        return &amp;ShortURLService{repositoryRead: repositoryRead, repositoryWrite: repositoryWrite}
}</span>

// FindByShortURL поиск по короткой ссылке
func (service *ShortURLService) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov0" title="0">{
        return service.repositoryRead.FindByShortURL(shortURL)
}</span>

// Save сохранение
func (service *ShortURLService) Save(ctx *gin.Context, url string) (*entity.ShortURLEntity, error) <span class="cov0" title="0">{
        addedUserID, exists := ctx.Get(middleware.UserIDProperty)

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user id is required")
        }</span>

        <span class="cov0" title="0">shortURL := utils.GenerateShortURL(url)

        model, errRepository := service.repositoryRead.FindByShortURL(shortURL)

        if errRepository != nil </span><span class="cov0" title="0">{
                return nil, errRepository
        }</span>

        <span class="cov0" title="0">if model != nil </span><span class="cov0" title="0">{
                return model, ErrEntityExists
        }</span>

        <span class="cov0" title="0">err := service.repositoryWrite.Save(shortURL, url, addedUserID.(string))

        if err != nil </span><span class="cov0" title="0">{
                return &amp;entity.ShortURLEntity{ShortURL: shortURL, URL: url}, err
        }</span>

        <span class="cov0" title="0">return &amp;entity.ShortURLEntity{ShortURL: shortURL, URL: url}, nil</span>
}

// Batch Массовое сохранение
func (service *ShortURLService) Batch(request []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        return service.repositoryWrite.Batch(request)
}</span>

// GetUrlsByUserID получение ссылок по пользователю
func (service *ShortURLService) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        return service.repositoryRead.GetUrlsByUserID(userID)
}</span>

// Delete удаление
func (service *ShortURLService) Delete(URLList []string, addedUserID string) <span class="cov8" title="1">{
        var chunk []string
        var chunks [][]string
        i := 0
        for _, URL := range URLList </span><span class="cov8" title="1">{
                chunk = append(chunk, URL)

                if i &lt; 10 </span><span class="cov8" title="1">{
                        i++
                }</span> else<span class="cov8" title="1"> {
                        chunks = append(chunks, chunk)
                        chunk = nil
                        i = 0
                }</span>

        }

        <span class="cov8" title="1">var deletedURLs []string
        if len(chunk) &gt; 0 </span><span class="cov8" title="1">{
                chunks = append(chunks, chunk)
                chunk = nil
        }</span>

        <span class="cov8" title="1">inCh := service.sendToPrepare(chunks)
        ch1 := service.prepareGoodURL(inCh, addedUserID)
        ch2 := service.prepareGoodURL(inCh, addedUserID)
        for n := range service.fanIn(ch1, ch2) </span><span class="cov8" title="1">{
                deletedURLs = append(deletedURLs, n...)
        }</span>

        <span class="cov8" title="1">service.notification(deletedURLs)</span>
}

// sendToPrepare отправляем в поток на обработку
func (service *ShortURLService) sendToPrepare(chunks [][]string) chan []string <span class="cov8" title="1">{
        outCh := make(chan []string)
        go func() </span><span class="cov8" title="1">{
                defer close(outCh)
                for _, chunk := range chunks </span><span class="cov8" title="1">{
                        outCh &lt;- chunk
                }</span>
        }()

        <span class="cov8" title="1">return outCh</span>
}

// Возвращаем только те URL, которые действо можно удалить
func (service *ShortURLService) prepareGoodURL(inCh chan []string, addedUserID string) chan []string <span class="cov8" title="1">{
        outCh := make(chan []string)

        go func() </span><span class="cov8" title="1">{
                defer close(outCh)
                for shortURLs := range inCh </span><span class="cov8" title="1">{
                        err := service.repositoryWrite.Delete(shortURLs, addedUserID)
                        if err != nil </span><span class="cov0" title="0">{
                                service.logger.Error("ошибка получения записей", zap.String("urls", strings.Join(shortURLs, ",")), zap.String("addedUserID", addedUserID), zap.Error(err))
                                return
                        }</span>

                        <span class="cov8" title="1">outCh &lt;- shortURLs</span>
                }
        }()

        <span class="cov8" title="1">return outCh</span>
}

// fanIn обработка потока
func (service *ShortURLService) fanIn(chs ...chan []string) chan []string <span class="cov8" title="1">{
        var wg sync.WaitGroup
        outCh := make(chan []string)

        // определяем функцию output для каждого канала в chs
        // функция output копирует значения из канала с в канал outCh, пока с не будет закрыт
        output := func(c chan []string) </span><span class="cov8" title="1">{
                for n := range c </span><span class="cov8" title="1">{
                        outCh &lt;- n
                }</span>
                <span class="cov8" title="1">wg.Done()</span>
        }

        // добавляем в группу столько горутин, сколько каналов пришло в fanIn
        <span class="cov8" title="1">wg.Add(len(chs))
        // перебираем все каналы, которые пришли и отправляем каждый в отдельную горутину
        for _, c := range chs </span><span class="cov8" title="1">{
                go output(c)
        }</span>

        // запускаем горутину для закрытия outCh после того, как все горутины отработают
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(outCh)
        }</span>()

        // возвращаем общий канал
        <span class="cov8" title="1">return outCh</span>
}

// notification уведомление о обработанных письмах
func (service *ShortURLService) notification(URLs []string) {<span class="cov8" title="1">
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package utils

import (
        "crypto/sha1"
        "encoding/base64"
)

// GenerateShortURL формированиерое краткого url
func GenerateShortURL(url string) string <span class="cov8" title="1">{
        hash := sha1.New()
        hash.Write([]byte(url))
        return base64.URLEncoding.EncodeToString(hash.Sum(nil))[:8]

}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package config

//  -a=http://localhost:8081/api/shorten -b=http://localhost:8081/api/shorten
import (
        "bytes"
        "cmp"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/json"
        "encoding/pem"
        "flag"
        "log"
        "math/big"
        "net"
        "os"
        "strconv"
        "time"
)

// Config структура
type Config struct {
        AddressStart string `json:"server_address"`
        BaseShort    string `json:"base_url"`
        FileStorage  string `json:"file_storage_path"`
        DatabaseURL  string `json:"database_dsn"`
        StorageType  string
        FullLog      bool
        HTTPS        struct {
                Enabled    bool `json:"enable_https"`
                SSLKeyPath string
                SSLPemPath string
        }
}

// StorageTypeMemory место зранения
const StorageTypeMemory = "Memory"

// StorageTypeFile место зранения
const StorageTypeFile = "File"

// StorageTypeDB место зранения
const StorageTypeDB = "DB"

// NewConfig получение конфигов
func NewConfig() *Config <span class="cov8" title="1">{
        var configPath string
        flag.StringVar(&amp;configPath, "c", "", "Path to config file")

        cfg := &amp;Config{}

        flag.StringVar(&amp;cfg.AddressStart, "a", "", "start url and port")
        flag.StringVar(&amp;cfg.BaseShort, "b", "", "url redirect")
        flag.StringVar(&amp;cfg.FileStorage, "f", "", "file storage path")
        flag.StringVar(&amp;cfg.DatabaseURL, "d", "", "database storage path")
        flag.BoolVar(&amp;cfg.HTTPS.Enabled, "s", false, "ssl enabled")
        flag.StringVar(&amp;cfg.HTTPS.SSLKeyPath, "sslk", "./auto_server.key", "Path to ssl key file")
        flag.StringVar(&amp;cfg.HTTPS.SSLPemPath, "sslp", "./auto_server.pem", "Path to ssl pem file")
        flag.Parse()

        preConfig := &amp;Config{}
        if configPath != "" </span><span class="cov0" title="0">{
                rawContent, err := os.ReadFile(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">if err = json.Unmarshal(rawContent, preConfig); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }

        <span class="cov8" title="1">cfg.AddressStart = cmp.Or(cfg.AddressStart, os.Getenv("SERVER_ADDRESS"), preConfig.AddressStart, "127.0.0.1:8086")
        cfg.BaseShort = cmp.Or(cfg.BaseShort, os.Getenv("BASE_URL"), preConfig.BaseShort, "127.0.0.1:8080")
        cfg.FileStorage = cmp.Or(cfg.FileStorage, os.Getenv("FILE_STORAGE_PATH"), preConfig.FileStorage)
        cfg.DatabaseURL = cmp.Or(cfg.DatabaseURL, os.Getenv("DATABASE_DSN"), preConfig.DatabaseURL)

        var storageType = StorageTypeMemory

        if cfg.FileStorage != "" || os.Getenv("FILE_STORAGE_PATH") != "" </span><span class="cov0" title="0">{
                storageType = StorageTypeFile
        }</span>

        <span class="cov8" title="1">if cfg.DatabaseURL != "" || os.Getenv("DATABASE_DSN") != "" </span><span class="cov0" title="0">{
                storageType = StorageTypeDB
        }</span>

        <span class="cov8" title="1">cfg.StorageType = storageType
        cfg.FullLog = true

        if envHTTPSStr := os.Getenv("ENABLE_HTTPS"); envHTTPSStr != "" </span><span class="cov0" title="0">{
                envHTTPS, err := strconv.ParseBool(envHTTPSStr)
                if err == nil </span><span class="cov0" title="0">{
                        cfg.HTTPS.Enabled = envHTTPS
                }</span>
        }

        <span class="cov8" title="1">if cfg.HTTPS.Enabled &amp;&amp; cfg.HTTPS.SSLKeyPath == "./auto_server.key" </span><span class="cov0" title="0">{
                CreateTLSCert("./auto_server.pem", "./auto_server.key")
        }</span>

        <span class="cov8" title="1">return cfg</span>
}

// CreateTLSCert - generate TLS certificate and key for run server HTTPS
func CreateTLSCert(certPath string, keyPath string) error <span class="cov0" title="0">{
        cert := x509.Certificate{
                SerialNumber: big.NewInt(1),
                Subject: pkix.Name{
                        Organization: []string{"artur.turundaev"},
                        Country:      []string{"RU"},
                        Province:     []string{"Moscow"},
                        Locality:     []string{"Moscow"},
                        CommonName:   "localhost",
                },
                NotBefore:             time.Now(),
                NotAfter:              time.Now().Add(365 * 24 * time.Hour),
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
                IPAddresses:           []net.IP{net.ParseIP("127.0.0.1")},
        }

        privateKey, _ := rsa.GenerateKey(rand.Reader, 4096)
        certBytes, _ := x509.CreateCertificate(rand.Reader, &amp;cert, &amp;cert, &amp;privateKey.PublicKey, privateKey)
        err := saveToFile(certPath, "CERTIFICATE", certBytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = saveToFile(keyPath, "RSA PRIVATE KEY", x509.MarshalPKCS1PrivateKey(privateKey))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func saveToFile(filePath string, cypherType string, cypher []byte) error <span class="cov0" title="0">{
        var (
                buf  bytes.Buffer
                file *os.File
        )

        _ = pem.Encode(&amp;buf, &amp;pem.Block{
                Type:  cypherType,
                Bytes: cypher,
        })

        file, err := os.Create(filePath)
        defer file.Close()

        _, err = buf.WriteTo(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package exitmain

import (
        "go/ast"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "honnef.co/go/tools/analysis/code"
        "strings"
)

// Analyzer - Check direct call to os.Exit in the main function
var Analyzer = &amp;analysis.Analyzer{
        Name:     "mainexit",
        Doc:      "Checking the use of a direct call to os.Exit in the main function of the main package",
        Run:      run,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
}

func run(pass *analysis.Pass) (interface{}, error) <span class="cov8" title="1">{
        if pass.Pkg.Name() != "main" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">fn := func(node ast.Node) </span><span class="cov8" title="1">{
                switch v := node.(type) </span>{
                case *ast.FuncDecl:<span class="cov8" title="1">
                        if v.Body == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">if v.Name.Name != "main" </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">if strings.HasSuffix(pass.Pkg.Path(), ".example") ||
                                strings.HasSuffix(pass.Pkg.Path(), ".test") ||
                                strings.HasSuffix(pass.Pkg.Path(), "benchmark") ||
                                strings.HasSuffix(pass.Pkg.Path(), "fuzz") </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">ast.Inspect(v, func(n ast.Node) bool </span><span class="cov8" title="1">{
                                ce, okCe := n.(*ast.CallExpr)
                                if !okCe </span><span class="cov8" title="1">{
                                        return true
                                }</span>

                                <span class="cov8" title="1">se, okSe := ce.Fun.(*ast.SelectorExpr)
                                if !okSe </span><span class="cov8" title="1">{
                                        return true
                                }</span>

                                <span class="cov8" title="1">if ident, ok := se.X.(*ast.Ident); ok &amp;&amp; ident.Name == "os" &amp;&amp; se.Sel.Name == "Exit" </span><span class="cov8" title="1">{
                                        pass.Reportf(se.Pos(), "avoid using os.Exit directly in main function")
                                }</span>

                                <span class="cov8" title="1">return false</span>
                        })
                }
        }
        //
        <span class="cov8" title="1">needle := []ast.Node{
                (*ast.FuncDecl)(nil),
        }

        code.Preorder(pass, fn, needle...)

        return nil, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
