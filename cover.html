
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>shortener: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/arturturundaev/shorturl/cmd/shortener/main.go (14.2%)</option>
				
				<option value="file1">github.com/arturturundaev/shorturl/cmd/staticlint/linter.go (75.0%)</option>
				
				<option value="file2">github.com/arturturundaev/shorturl/internal/app/handler/batch/batch_handler.go (85.0%)</option>
				
				<option value="file3">github.com/arturturundaev/shorturl/internal/app/handler/batch/batch_request.go (83.3%)</option>
				
				<option value="file4">github.com/arturturundaev/shorturl/internal/app/handler/delete/delete_handler.go (87.5%)</option>
				
				<option value="file5">github.com/arturturundaev/shorturl/internal/app/handler/find/find_handler.go (100.0%)</option>
				
				<option value="file6">github.com/arturturundaev/shorturl/internal/app/handler/ping/ping_handler.go (88.9%)</option>
				
				<option value="file7">github.com/arturturundaev/shorturl/internal/app/handler/save/save_handler.go (82.4%)</option>
				
				<option value="file8">github.com/arturturundaev/shorturl/internal/app/handler/shorten/shorten_handler.go (100.0%)</option>
				
				<option value="file9">github.com/arturturundaev/shorturl/internal/app/handler/shorten/shorten_request.go (100.0%)</option>
				
				<option value="file10">github.com/arturturundaev/shorturl/internal/app/handler/stats/url_and_users.go (100.0%)</option>
				
				<option value="file11">github.com/arturturundaev/shorturl/internal/app/handler/user/url_handler.go (92.9%)</option>
				
				<option value="file12">github.com/arturturundaev/shorturl/internal/app/handler/user/url_list_response.go (100.0%)</option>
				
				<option value="file13">github.com/arturturundaev/shorturl/internal/app/middleware/jwt.go (86.5%)</option>
				
				<option value="file14">github.com/arturturundaev/shorturl/internal/app/middleware/trusted_subnet.go (90.0%)</option>
				
				<option value="file15">github.com/arturturundaev/shorturl/internal/app/proto/proto.pb.go (9.8%)</option>
				
				<option value="file16">github.com/arturturundaev/shorturl/internal/app/proto/proto_grpc.pb.go (0.0%)</option>
				
				<option value="file17">github.com/arturturundaev/shorturl/internal/app/proto/server.go (0.0%)</option>
				
				<option value="file18">github.com/arturturundaev/shorturl/internal/app/repository/filestorage/file_storage_repository.go (75.6%)</option>
				
				<option value="file19">github.com/arturturundaev/shorturl/internal/app/repository/localstorage/local_storage_repository.go (85.3%)</option>
				
				<option value="file20">github.com/arturturundaev/shorturl/internal/app/repository/postgres/postgres.go (61.3%)</option>
				
				<option value="file21">github.com/arturturundaev/shorturl/internal/app/service/ping_service.go (50.0%)</option>
				
				<option value="file22">github.com/arturturundaev/shorturl/internal/app/service/short_url_service.go (89.4%)</option>
				
				<option value="file23">github.com/arturturundaev/shorturl/internal/app/service/stats_service.go (100.0%)</option>
				
				<option value="file24">github.com/arturturundaev/shorturl/internal/app/utils/short_url_generator.go (100.0%)</option>
				
				<option value="file25">github.com/arturturundaev/shorturl/internal/config/config.go (87.9%)</option>
				
				<option value="file26">github.com/arturturundaev/shorturl/internal/pkg/analyser/exitmain/exitmain.go (91.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "fmt"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        deleteUrl "github.com/arturturundaev/shorturl/internal/app/handler/delete"
        "github.com/arturturundaev/shorturl/internal/app/handler/find"
        "github.com/arturturundaev/shorturl/internal/app/handler/ping"
        "github.com/arturturundaev/shorturl/internal/app/handler/save"
        "github.com/arturturundaev/shorturl/internal/app/handler/shorten"
        "github.com/arturturundaev/shorturl/internal/app/handler/stats"
        "github.com/arturturundaev/shorturl/internal/app/handler/user"
        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/arturturundaev/shorturl/internal/app/proto"
        "github.com/arturturundaev/shorturl/internal/app/repository/filestorage"
        "github.com/arturturundaev/shorturl/internal/app/repository/localstorage"
        pg "github.com/arturturundaev/shorturl/internal/app/repository/postgres"
        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/arturturundaev/shorturl/internal/config"
        "github.com/gin-contrib/gzip"
        "github.com/gin-contrib/pprof"
        ginzap "github.com/gin-contrib/zap"
        "github.com/gin-gonic/gin"
        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/pgx/v5"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/jmoiron/sqlx"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "google.golang.org/grpc"
        "io"
        "log"
        "net"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"
)

// Build variables
var (
        // BuildVersion - version
        BuildVersion string = "N/A"
        // BuildDate - date
        BuildDate string = "N/A"
        // BuildCommit - commit
        BuildCommit string = "N/A"
)

// -d=postgres://postgres:postgres@localhost:5432/shorturl?sslmode=disable
// SaveFullURL создание
const SaveFullURL = `/`

// GetFullURL получение
const GetFullURL = `/:short`

// SaveFullURL2 v2
const SaveFullURL2 = `/api/shorten`

// SaveBatch массовое сохранение
const SaveBatch = `/api/shorten/batch`

// Ping пинг
const Ping = `/ping`

// URLByUser получение по пользователю
const URLByUser = `/api/user/urls`

// DeleteByUrls удаление ссылок
const DeleteByUrls = `/api/user/urls`

// UserUrlsCountStat
const UserUrlsCountStat = `/api/internal/stats`

func main() <span class="cov0" title="0">{
        startServe()
}</span>

func startServe() <span class="cov0" title="0">{

        serverConfig, logger, jwtValidate, trustedSubnet, shortURLService, pingService, statService, repoRW := getResources()

        router := initRouter(shortURLService, serverConfig, pingService, statService, jwtValidate, trustedSubnet)

        logger.Info(fmt.Sprintf("Build version: %s\n", BuildVersion))
        logger.Info(fmt.Sprintf("Build date: %s\n", BuildDate))
        logger.Info(fmt.Sprintf("Build commit: %s\n", BuildCommit))

        if serverConfig.GRPCAddr != "" </span><span class="cov0" title="0">{

                // определяем порт для сервера
                listen, err := net.Listen("tcp", serverConfig.GRPCAddr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                // создаём gRPC-сервер без зарегистрированной службы
                <span class="cov0" title="0">s := grpc.NewServer()
                // регистрируем сервис
                proto.RegisterServiceServer(s, proto.NewGPRCServer(pingService, statService))

                fmt.Println("Сервер gRPC начал работу " + serverConfig.GRPCAddr)
                // получаем запрос gRPC
                if err := s.Serve(listen); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                log.Println("panic occurred:", err)
                        }</span>
                }()
        } else<span class="cov0" title="0"> {

                logger.Info("server start on port: " + serverConfig.AddressStart)
                server := &amp;http.Server{
                        Addr:    serverConfig.AddressStart,
                        Handler: router,
                }

                go func() </span><span class="cov0" title="0">{
                        signalChan := make(chan os.Signal, 1)
                        signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
                        &lt;-signalChan
                        repoRW.SaveToFile("/tmp/save.txt")
                        os.Exit(0)
                }</span>()

                <span class="cov0" title="0">var errServer error
                if serverConfig.HTTPS.Enabled </span><span class="cov0" title="0">{
                        errServer = server.ListenAndServeTLS(serverConfig.HTTPS.SSLPemPath, serverConfig.HTTPS.SSLKeyPath)
                }</span> else<span class="cov0" title="0"> {
                        errServer = server.ListenAndServe()
                }</span>
                <span class="cov0" title="0">if errServer != nil </span><span class="cov0" title="0">{
                        logger.Fatal(errServer.Error())
                }</span>
        }
}

func initRouter(shortURLService *service.ShortURLService, serverConfig *config.Config, pingService *service.PingService, statService *service.StatService, jwtValidate *middleware.JWTValidator, trustedSubnet *middleware.TrustedSubnetMiddleware) *gin.Engine <span class="cov0" title="0">{

        router := gin.Default()

        router.Use(gzip.Gzip(gzip.DefaultCompression, gzip.WithDecompressFn(gzip.DefaultDecompressHandle)))

        handlerFind := find.NewFindHandler(shortURLService)
        handlerSave := save.NewSaveHandler(shortURLService, serverConfig.BaseShort)
        handlerShortener := shorten.NewShortenHandler(shortURLService, serverConfig.BaseShort)
        handlerPing := ping.NewPingHandler(pingService)
        handlerButch := batch.NewButchHandler(shortURLService, serverConfig.BaseShort)
        handlerFindByUser := user.NewURLFindByUserHandler(shortURLService, serverConfig.BaseShort)
        handlerDelete := deleteUrl.NewDeleteHandler(shortURLService)
        handlerUsersUrlsCount := stats.NewUrlsAndUsersStatHandler(statService)

        router.GET(Ping, handlerPing.Handle)
        router.POST(SaveFullURL, jwtValidate.Handle, handlerSave.Handle)
        router.GET(GetFullURL, handlerFind.Handle)
        router.POST(SaveFullURL2, jwtValidate.Handle, handlerShortener.Handle)
        router.POST(SaveBatch, handlerButch.Handle)
        router.GET(URLByUser, jwtValidate.Handle, handlerFindByUser.Handle)
        router.DELETE(DeleteByUrls, jwtValidate.Handle, handlerDelete.Handle)
        router.GET(UserUrlsCountStat, trustedSubnet.Handle, handlerUsersUrlsCount.Handle)

        pprof.Register(router, "dev/pprof")

        return router
}</span>

func getResources() (*config.Config, *zap.Logger, *middleware.JWTValidator, *middleware.TrustedSubnetMiddleware, *service.ShortURLService, *service.PingService, *service.StatService, service.RepositoryWriter) <span class="cov0" title="0">{

        serverConfig := config.NewConfig()

        logger, err := addLogger(nil, serverConfig.FullLog)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err.Error())
                os.Exit(5)
        }</span>

        <span class="cov0" title="0">repositoryRead, repositoryWrite := getRepository(serverConfig, logger)

        if repositoryRead == nil </span><span class="cov0" title="0">{
                logger.Error("ошибка инициализации репозитория на чтение. Тип репозитория: " + config.StorageTypeDB)
        }</span>

        <span class="cov0" title="0">if repositoryWrite == nil </span><span class="cov0" title="0">{
                logger.Error("ошибка инициализации репозитория на запись. Тип репозитория: " + config.StorageTypeDB)
        }</span>

        <span class="cov0" title="0">if serverConfig.StorageType == config.StorageTypeDB </span><span class="cov0" title="0">{
                absPath, errPathMigration := filepath.Abs(".")
                if errPathMigration != nil </span><span class="cov0" title="0">{
                        logger.Error("ошибка определения директории для миграций!")
                }</span> else<span class="cov0" title="0"> {
                        initMigrations("file:////"+absPath+"/internal/app/repository/postgres/migration", repositoryRead.GetDB())
                }</span>
        }

        <span class="cov0" title="0">jwtValidate := middleware.NewJWTValidator(serverConfig.AddressStart)
        trustedSubnet := middleware.NewTrustedSubnetMiddleware(serverConfig.TrustedSubnetFinal)

        shortURLService := service.NewShortURLService(repositoryRead, repositoryWrite)

        pingService := service.NewPingService(repositoryRead)

        statService := service.NewStatService(repositoryRead)

        return serverConfig, logger, jwtValidate, trustedSubnet, shortURLService, pingService, statService, repositoryWrite</span>
}

func addLogger(r *gin.Engine, fullLogger bool) (*zap.Logger, error) <span class="cov10" title="2">{
        logger, err := zap.NewProduction()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">if fullLogger &amp;&amp; r != nil </span><span class="cov1" title="1">{
                r.Use(ginzap.Ginzap(logger, time.RFC3339, true))
                r.Use(ginzap.RecoveryWithZap(logger, true))
                r.Use(ginzap.GinzapWithConfig(logger, &amp;ginzap.Config{
                        UTC:        true,
                        TimeFormat: time.RFC3339,
                        Context: ginzap.Fn(func(c *gin.Context) []zapcore.Field </span><span class="cov0" title="0">{
                                var fields []zapcore.Field
                                // log request ID
                                if requestID := c.Writer.Header().Get("X-Request-Id"); requestID != "" </span><span class="cov0" title="0">{
                                        fields = append(fields, zap.String("request_id", requestID))
                                }</span>

                                // log request body
                                <span class="cov0" title="0">var body []byte
                                var buf bytes.Buffer
                                tee := io.TeeReader(c.Request.Body, &amp;buf)
                                body, _ = io.ReadAll(tee)
                                c.Request.Body = io.NopCloser(&amp;buf)
                                fields = append(fields, zap.String("body", string(body)))

                                return fields</span>
                        }),
                }))
        }

        <span class="cov10" title="2">return logger, nil</span>
}

func initMigrations(migrationPath string, DB *sqlx.DB) <span class="cov0" title="0">{
        driver, err := postgres.WithInstance(DB.DB, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                migrationPath,
                "postgres", driver)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span> else<span class="cov0" title="0"> {
                errMigrate := m.Up()
                if errMigrate != nil &amp;&amp; errMigrate.Error() != "no change" </span><span class="cov0" title="0">{
                        log.Fatal(errMigrate)
                }</span>
        }
}

func getRepository(serverConfig *config.Config, logger *zap.Logger) (service.RepositoryReader, service.RepositoryWriter) <span class="cov10" title="2">{

        if serverConfig.StorageType == config.StorageTypeDB </span><span class="cov0" title="0">{
                database, err := sqlx.Open("postgres", serverConfig.DatabaseURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">repository, errPingRepo := pg.NewPostgresRepository(database)
                if errPingRepo != nil </span><span class="cov0" title="0">{
                        logger.Error(errPingRepo.Error())
                }</span>

                <span class="cov0" title="0">return repository, repository</span>
        }

        <span class="cov10" title="2">if serverConfig.StorageType == config.StorageTypeFile </span><span class="cov1" title="1">{
                repositoryWrite, errStorageWrite := filestorage.NewFileStorageRepositoryWrite(serverConfig.FileStorage)
                if errStorageWrite != nil </span><span class="cov0" title="0">{
                        logger.Error(errStorageWrite.Error())
                }</span>

                <span class="cov1" title="1">repositoryRead, errStorageRead := filestorage.NewFileStorageRepositoryRead(serverConfig.FileStorage)
                if errStorageRead != nil </span><span class="cov0" title="0">{
                        logger.Error(errStorageRead.Error())
                }</span>

                <span class="cov1" title="1">return repositoryRead, repositoryWrite</span>
        }

        <span class="cov1" title="1">if serverConfig.StorageType == config.StorageTypeMemory </span><span class="cov1" title="1">{
                repositoryWrite := localstorage.NewLocalStorageRepository()

                return repositoryWrite, repositoryWrite
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package staticlint

import (
        "github.com/arturturundaev/shorturl/internal/pkg/analyser/exitmain"
        "github.com/gordonklaus/ineffassign/pkg/ineffassign"
        "github.com/timakin/bodyclose/passes/bodyclose"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/appends"
        "golang.org/x/tools/go/analysis/passes/errorsas"
        "golang.org/x/tools/go/analysis/passes/httpresponse"
        "golang.org/x/tools/go/analysis/passes/lostcancel"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "golang.org/x/tools/go/analysis/passes/testinggoroutine"
        "golang.org/x/tools/go/analysis/passes/unmarshal"
        "golang.org/x/tools/go/analysis/passes/unreachable"
        "honnef.co/go/tools/quickfix/qf1001"
        "honnef.co/go/tools/simple"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck/st1001"
)

func main() <span class="cov0" title="0">{
        checks := getChecks()

        multichecker.Main(
                checks...,
        )
}</span>

func getChecks() []*analysis.Analyzer <span class="cov1" title="1">{
        checks := []*analysis.Analyzer{
                // check consistency of Printf format strings and arguments
                printf.Analyzer,
                // check for possible unintended shadowing of variables
                shadow.Analyzer,
                // check that struct field tags
                structtag.Analyzer,
                // checks for unreachable code
                unreachable.Analyzer,
                // report passing non-pointer or non-interface values to unmarshal
                unmarshal.Analyzer,
                // report calls to (*testing.T).Fatal from goroutines started by a test
                testinggoroutine.Analyzer,
                // check cancel func returned by context.WithCancel is called
                lostcancel.Analyzer,
                // check for mistakes using HTTP responses
                httpresponse.Analyzer,
                errorsas.Analyzer,
                // report passing non-pointer or non-error values to errors.As
                appends.Analyzer,
                // dot imports are discouraged
                st1001.Analyzer,
                // Apply De Morgan's law
                qf1001.Analyzer,
                // detect ineffectual assignments in Go code
                ineffassign.Analyzer,
                // checks whether HTTP response body is closed successfully
                bodyclose.Analyzer,
                // Checking the use of a direct call to os.Exit in the main function of the main package
                exitmain.Analyzer,
        }

        for _, v := range staticcheck.Analyzers </span><span class="cov10" title="95">{
                checks = append(checks, v.Analyzer)
        }</span>

        <span class="cov1" title="1">for _, v := range simple.Analyzers </span><span class="cov8" title="35">{
                checks = append(checks, v.Analyzer)
        }</span>

        <span class="cov1" title="1">return checks</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package batch

import (
        "encoding/json"
        "fmt"
        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/gin-gonic/gin"
        "net/http"
)

type serviceURLButcher interface {
        Batch(request []ButchRequest) ([]entity.ShortURLEntity, error)
}

// ButchHandler ButchHandler
type ButchHandler struct {
        service serviceURLButcher
        baseURL string
}

// NewButchHandler конструктор
func NewButchHandler(service serviceURLButcher, baseURL string) *ButchHandler <span class="cov0" title="0">{
        return &amp;ButchHandler{service: service, baseURL: baseURL}
}</span>

// Handle массовоt создание
func (h *ButchHandler) Handle(ctx *gin.Context) <span class="cov10" title="3">{
        var response []ButchResponse
        request, err := NewButchRequest(ctx)
        if err != nil </span><span class="cov1" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov6" title="2">models, err := h.service.Batch(request)
        if err != nil </span><span class="cov1" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">for _, model := range models </span><span class="cov1" title="1">{
                response = append(response, ButchResponse{CorrelationID: model.CorrelationID, ShortURL: fmt.Sprintf("%s/%s", h.baseURL, model.ShortURL)})
        }</span>

        <span class="cov1" title="1">bt, errMarshal := json.Marshal(response)

        if errMarshal != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": errMarshal.Error()})
                return
        }</span>

        <span class="cov1" title="1">ctx.Writer.Header().Set("Accept-Encoding", "gzip")
        ctx.Writer.Header().Set("Content-Encoding", "gzip")
        ctx.Writer.Header().Set("Content-Type", "application/json")
        ctx.Data(http.StatusCreated, "gzip", bt)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package batch

import (
        "fmt"

        "github.com/gin-gonic/gin"
)

// ButchRequest dto
type ButchRequest struct {
        CorrelationID string `json:"correlation_id"`
        OriginalURL   string `json:"original_url"`
}

// NewButchRequest конструктор
func NewButchRequest(context *gin.Context) ([]ButchRequest, error) <span class="cov10" title="3">{
        var dto []ButchRequest

        if err := context.BindJSON(&amp;dto); err != nil </span><span class="cov1" title="1">{
                return dto, err
        }</span>

        <span class="cov6" title="2">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("пустой входной массив")
        }</span>

        <span class="cov6" title="2">return dto, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package delete

import (
        "encoding/json"
        "io"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/gin-gonic/gin"
)

type deleter interface {
        Delete(URLList []string, addedUserID string)
}

// DeleteHandler сервис
type DeleteHandler struct {
        service deleter
}

// NewDeleteHandler конструктор
func NewDeleteHandler(service deleter) *DeleteHandler <span class="cov1" title="1">{
        return &amp;DeleteHandler{service: service}
}</span>

// Handle обработчик удаления
func (h *DeleteHandler) Handle(ctx *gin.Context) <span class="cov10" title="3">{
        var data []string
        body, err := io.ReadAll(ctx.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov10" title="3">err = json.Unmarshal(body, &amp;data)
        if err != nil </span><span class="cov1" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov6" title="2">addedUserID, exists := ctx.Get(middleware.UserIDProperty)

        if !exists </span><span class="cov1" title="1">{
                ctx.Status(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov1" title="1">go h.service.Delete(data, addedUserID.(string))

        ctx.Status(http.StatusAccepted)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package find

import (
        "fmt"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/gin-gonic/gin"
)

// FindHandler сервис
type FindHandler struct {
        service *service.ShortURLService
}

// NewFindHandler конструктор
func NewFindHandler(service *service.ShortURLService) *FindHandler <span class="cov1" title="1">{
        return &amp;FindHandler{service: service}
}</span>

// Handle обработчик поиска
func (hndlr *FindHandler) Handle(ctx *gin.Context) <span class="cov10" title="3">{

        data, err := hndlr.service.FindByShortURL(ctx.Param("short"))

        if err != nil || data == nil </span><span class="cov1" title="1">{
                er := err
                if data == nil </span><span class="cov1" title="1">{
                        er = fmt.Errorf("not find")
                }</span>
                <span class="cov1" title="1">ctx.String(http.StatusBadRequest, "%s", er.Error())
                ctx.Abort()
                return</span>
        }

        <span class="cov6" title="2">if data.IsDeleted </span><span class="cov1" title="1">{
                ctx.Status(http.StatusGone)
                ctx.Abort()
                return
        }</span>

        <span class="cov1" title="1">ctx.Redirect(http.StatusTemporaryRedirect, data.URL)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package ping

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

type pignger interface {
        Ping(ctx context.Context) error
}

// PingHandler сервис
type PingHandler struct {
        service pignger
}

// NewPingHandler конструктор
func NewPingHandler(service pignger) *PingHandler <span class="cov0" title="0">{
        return &amp;PingHandler{service: service}
}</span>

// Handle обработчик поиска
func (h *PingHandler) Handle(ctx *gin.Context) <span class="cov10" title="2">{

        contxt, cancel := context.WithCancel(ctx)
        defer cancel()
        time.AfterFunc(1500*time.Millisecond, cancel)

        err := h.service.Ping(contxt)

        if err != nil </span><span class="cov1" title="1">{
                ctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">ctx.AbortWithStatusJSON(http.StatusOK, "")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package save

import (
        "errors"
        "io"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/gin-gonic/gin"
)

// SaveHandler сервис
type SaveHandler struct {
        service *service.ShortURLService
        baseURL string
}

// NewSaveHandler конструктор
func NewSaveHandler(service *service.ShortURLService, baseURL string) *SaveHandler <span class="cov1" title="1">{
        return &amp;SaveHandler{service: service, baseURL: baseURL}
}</span>

// Handle обработчик сохранения
func (hndlr *SaveHandler) Handle(ctx *gin.Context) <span class="cov10" title="3">{
        b, err := io.ReadAll(ctx.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov10" title="3">data, err := hndlr.service.Save(ctx, string(b))

        if errors.Is(err, service.ErrEntityExists) </span><span class="cov1" title="1">{
                ctx.Header("Content-type", "text/plain")
                ctx.String(http.StatusConflict, "%s/%s", hndlr.baseURL, data.ShortURL)
                return
        }</span>

        <span class="cov6" title="2">if err != nil </span><span class="cov1" title="1">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov1" title="1">ctx.Header("Content-type", "text/plain")
        ctx.String(http.StatusCreated, "%s/%s", hndlr.baseURL, data.ShortURL)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package shorten

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/service"
        "github.com/gin-gonic/gin"
)

// Handle интерфейс для сохранения
type URLSaver interface {
        Save(ctx *gin.Context, url string) (*entity.ShortURLEntity, error)
}

// Handle сервис
type ShortenHandler struct {
        service URLSaver
        baseURL string
}

// Handle конструктор
func NewShortenHandler(service URLSaver, baseURL string) *ShortenHandler <span class="cov1" title="1">{
        return &amp;ShortenHandler{service: service, baseURL: baseURL}
}</span>

// Handle обаботчик
func (h *ShortenHandler) Handle(ctx *gin.Context) <span class="cov10" title="7">{
        dto, errGenerateShortURL := NewShortenRequest(ctx)

        if errGenerateShortURL != nil </span><span class="cov7" title="4">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": errGenerateShortURL.Error()})
                return
        }</span>

        <span class="cov6" title="3">data, errRepository := h.service.Save(ctx, dto.URL)

        if errRepository != nil &amp;&amp; !errors.Is(errRepository, service.ErrEntityExists) </span><span class="cov1" title="1">{
                ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": errRepository.Error()})
                return
        }</span>

        <span class="cov4" title="2">response := ShortenResponse{URL: fmt.Sprintf("%s/%s", h.baseURL, data.ShortURL)}

        status := http.StatusCreated

        if errors.Is(errRepository, service.ErrEntityExists) </span><span class="cov1" title="1">{
                status = http.StatusConflict
        }</span>

        <span class="cov4" title="2">ctx.JSON(status, response)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package shorten

import (
        "github.com/gin-gonic/gin"
)

// ShortenRequest dto
type ShortenRequest struct {
        URL string `json:"url" binding:"required"`
}

// NewShortenRequest конструктор
func NewShortenRequest(context *gin.Context) (*ShortenRequest, error) <span class="cov10" title="9">{
        dto := &amp;ShortenRequest{}

        if err := context.BindJSON(dto); err != nil </span><span class="cov7" title="5">{
                return dto, err
        }</span>

        <span class="cov6" title="4">return dto, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package stats

import (
        "github.com/gin-gonic/gin"
        "net/http"
)

type UrlsAndUsersStatHandler struct {
        service UrlsAndUsersStatService
}

type UrlsAndUsersStatService interface {
        GetUrlsAndUsersStat() (int32, int32)
}

func NewUrlsAndUsersStatHandler(service UrlsAndUsersStatService) *UrlsAndUsersStatHandler <span class="cov8" title="1">{
        return &amp;UrlsAndUsersStatHandler{service: service}
}</span>

func (h *UrlsAndUsersStatHandler) Handle(ctx *gin.Context) <span class="cov8" title="1">{
        urlsCount, usersCount := h.service.GetUrlsAndUsersStat()

        type response struct {
                Urls  int32 `json:"urls"`
                Users int32 `json:"users"`
        }

        ctx.JSON(http.StatusOK, response{
                Urls:  urlsCount,
                Users: usersCount,
        })
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package user

import (
        "net/http"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/gin-gonic/gin"
)

// Handle интерфейс поиска ссылок по пользователю
type URLServiceFinder interface {
        GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error)
}

// Handle сервис
type URLFindByUserHandler struct {
        service URLServiceFinder
        baseURL string
}

// Handle конструктор
func NewURLFindByUserHandler(service URLServiceFinder, baseURL string) *URLFindByUserHandler <span class="cov0" title="0">{
        return &amp;URLFindByUserHandler{service: service, baseURL: baseURL}
}</span>

// Handle обработчик
func (handler *URLFindByUserHandler) Handle(ctx *gin.Context) <span class="cov10" title="3">{
        addedUserID, _ := ctx.Get(middleware.UserIDProperty)

        data, err := handler.service.GetUrlsByUserID(addedUserID.(string))

        if err != nil </span><span class="cov1" title="1">{
                ctx.String(http.StatusBadRequest, "%s", err.Error())
                ctx.Abort()
                return
        }</span>

        <span class="cov6" title="2">if len(data) == 0 </span><span class="cov1" title="1">{
                ctx.Status(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov1" title="1">var response []URLListItemResponse

        for _, url := range data </span><span class="cov1" title="1">{
                response = append(response, NewURLResponse(handler.baseURL, url.ShortURL, url.URL))
        }</span>
        <span class="cov1" title="1">ctx.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package user

import "fmt"

// URLListItemResponse dto
type URLListItemResponse struct {
        ShortURL  string `json:"short_url"`
        OriginURL string `json:"original_url"`
}

// NewURLResponse конструктор
func NewURLResponse(baseURL, shortURL, originURL string) URLListItemResponse <span class="cov8" title="1">{
        return URLListItemResponse{OriginURL: originURL, ShortURL: fmt.Sprintf("%s/%s", baseURL, shortURL)}
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// JWTValidator сервис
type JWTValidator struct {
        Claims Claims
        domain string
}

// Claims структура
type Claims struct {
        jwt.RegisteredClaims
        UserID string
}

// TokenExp время жизни токена
const TokenExp = 3 * time.Hour

// SecretKey ключ шифрования
const SecretKey = "0N#6Ke|+OR:(`G;"

// UserIDProperty в каком поле храниться ID пользователя
const UserIDProperty = "UserId"

// NewJWTValidator конструктор
func NewJWTValidator(domain string) *JWTValidator <span class="cov6" title="3">{
        return &amp;JWTValidator{domain: domain}
}</span>

// Handle обработка проверки токена
func (JWTValidator *JWTValidator) Handle(ctx *gin.Context) <span class="cov10" title="6">{
        var err error
        token, _ := ctx.Cookie("Authorization")

        if token == "" </span><span class="cov7" title="4">{
                token, err = JWTValidator.BuildJWTString(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(http.StatusForbidden, err)
                }</span>
        } else<span class="cov4" title="2"> {
                errorValidateToken := JWTValidator.ValidateJWT(ctx, token)
                if errorValidateToken != nil </span><span class="cov1" title="1">{
                        token, err = JWTValidator.BuildJWTString(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                ctx.AbortWithStatusJSON(http.StatusForbidden, err)
                        }</span>
                }
        }

        <span class="cov10" title="6">claims := &amp;Claims{}
        // парсим из строки токена tokenString в структуру claims
        jwt.ParseWithClaims(token, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov10" title="6">{
                return []byte(SecretKey), nil
        }</span>)

        <span class="cov10" title="6">ctx.Set(UserIDProperty, claims.UserID)
        ctx.Header("Authorization", token)

        ctx.SetCookie("Authorization", token, 100000, "*", JWTValidator.domain, false, true)</span>

}

// ValidateJWT проверка токена
func (JWTValidator *JWTValidator) ValidateJWT(ctx *gin.Context, tokenString string) error <span class="cov4" title="2">{
        claims := &amp;Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims,
                func(t *jwt.Token) (interface{}, error) </span><span class="cov1" title="1">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov1" title="1">return []byte(SecretKey), nil</span>
                })
        <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return fmt.Errorf("token is not valid")
        }</span>

        <span class="cov1" title="1">ctx.Set(UserIDProperty, claims.UserID)

        return nil</span>
}

// BuildJWTString формирование токена
func (JWTValidator *JWTValidator) BuildJWTString(ctx *gin.Context) (string, error) <span class="cov10" title="6">{
        userID := JWTValidator.getNewUserID()
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(TokenExp)),
                },
                UserID: userID,
        })

        tokenString, err := token.SignedString([]byte(SecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov10" title="6">ctx.Set(UserIDProperty, userID)

        return tokenString, nil</span>
}

func (JWTValidator *JWTValidator) getNewUserID() string <span class="cov10" title="6">{
        return uuid.New().String()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "net"
        "net/http"
)

type TrustedSubnetMiddleware struct {
        subnets []*net.IPNet
}

// NewTrustedSubnetMiddleware
func NewTrustedSubnetMiddleware(subnets []*net.IPNet) *TrustedSubnetMiddleware <span class="cov0" title="0">{
        return &amp;TrustedSubnetMiddleware{subnets: subnets}
}</span>

// Handle
func (h *TrustedSubnetMiddleware) Handle(c *gin.Context) <span class="cov5" title="2">{
        ip := c.ClientIP()
        if !isIPInSubnet(ip, h.subnets) </span><span class="cov1" title="1">{
                c.AbortWithStatus(http.StatusForbidden)
        }</span>
        <span class="cov5" title="2">c.Next()</span>
}

// IsIPInSubnet
func isIPInSubnet(ip string, subnets []*net.IPNet) bool <span class="cov10" title="4">{
        ipNet := net.ParseIP(ip)
        for _, subnet := range subnets </span><span class="cov10" title="4">{
                if subnet.Contains(ipNet) </span><span class="cov5" title="2">{
                        return true
                }</span>
        }
        <span class="cov5" title="2">return false</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v3.12.4
// source: internal/app/proto/proto.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PingRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *PingRequest) Reset() <span class="cov0" title="0">{
        *x = PingRequest{}
        mi := &amp;file_internal_app_proto_proto_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_proto_proto_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingRequest.ProtoReflect.Descriptor instead.
func (*PingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_proto_proto_proto_rawDescGZIP(), []int{0}
}</span>

type PingResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Code  int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
        Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *PingResponse) Reset() <span class="cov0" title="0">{
        *x = PingResponse{}
        mi := &amp;file_internal_app_proto_proto_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_proto_proto_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingResponse.ProtoReflect.Descriptor instead.
func (*PingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_proto_proto_proto_rawDescGZIP(), []int{1}
}</span>

func (x *PingResponse) GetCode() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PingResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StatRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
}

func (x *StatRequest) Reset() <span class="cov0" title="0">{
        *x = StatRequest{}
        mi := &amp;file_internal_app_proto_proto_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_proto_proto_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatRequest.ProtoReflect.Descriptor instead.
func (*StatRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_proto_proto_proto_rawDescGZIP(), []int{2}
}</span>

func (x *StatRequest) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StatsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Code  int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
        Urls  int32 `protobuf:"varint,2,opt,name=urls,proto3" json:"urls,omitempty"`
        Users int32 `protobuf:"varint,3,opt,name=users,proto3" json:"users,omitempty"`
}

func (x *StatsResponse) Reset() <span class="cov0" title="0">{
        *x = StatsResponse{}
        mi := &amp;file_internal_app_proto_proto_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_proto_proto_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsResponse.ProtoReflect.Descriptor instead.
func (*StatsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_proto_proto_proto_rawDescGZIP(), []int{3}
}</span>

func (x *StatsResponse) GetCode() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetUrls() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Urls
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetUsers() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Users
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_internal_app_proto_proto_proto protoreflect.FileDescriptor

var file_internal_app_proto_proto_proto_rawDesc = []byte{
        0x0a, 0x1e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x61, 0x70, 0x70, 0x2f, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x12, 0x17, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x22, 0x0d, 0x0a, 0x0b, 0x50, 0x69, 0x6e,
        0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x38, 0x0a, 0x0c, 0x50, 0x69, 0x6e, 0x67,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x14, 0x0a, 0x05,
        0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72,
        0x6f, 0x72, 0x22, 0x23, 0x0a, 0x0b, 0x53, 0x74, 0x61, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x22, 0x4d, 0x0a, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x73,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x12, 0x0a, 0x04,
        0x75, 0x72, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x75, 0x72, 0x6c, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x75, 0x73, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x05, 0x75, 0x73, 0x65, 0x72, 0x73, 0x32, 0xb7, 0x01, 0x0a, 0x07, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x12, 0x57, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x12, 0x24, 0x2e,
        0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2e, 0x61,
        0x70, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x2e, 0x53, 0x74,
        0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x53, 0x0a, 0x04, 0x50,
        0x69, 0x6e, 0x67, 0x12, 0x24, 0x2e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2e, 0x61,
        0x70, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x2e, 0x50, 0x69,
        0x6e, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x69, 0x6e, 0x74, 0x65,
        0x72, 0x6e, 0x61, 0x6c, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x73,
        0x74, 0x61, 0x74, 0x2e, 0x50, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x42, 0x04, 0x5a, 0x02, 0x2e, 0x2f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_internal_app_proto_proto_proto_rawDescOnce sync.Once
        file_internal_app_proto_proto_proto_rawDescData = file_internal_app_proto_proto_proto_rawDesc
)

func file_internal_app_proto_proto_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_internal_app_proto_proto_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_internal_app_proto_proto_proto_rawDescData = protoimpl.X.CompressGZIP(file_internal_app_proto_proto_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_internal_app_proto_proto_proto_rawDescData</span>
}

var file_internal_app_proto_proto_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_internal_app_proto_proto_proto_goTypes = []any{
        (*PingRequest)(nil),   // 0: internal.app.proto.stat.PingRequest
        (*PingResponse)(nil),  // 1: internal.app.proto.stat.PingResponse
        (*StatRequest)(nil),   // 2: internal.app.proto.stat.StatRequest
        (*StatsResponse)(nil), // 3: internal.app.proto.stat.StatsResponse
}
var file_internal_app_proto_proto_proto_depIdxs = []int32{
        2, // 0: internal.app.proto.stat.Service.GetStat:input_type -&gt; internal.app.proto.stat.StatRequest
        0, // 1: internal.app.proto.stat.Service.Ping:input_type -&gt; internal.app.proto.stat.PingRequest
        3, // 2: internal.app.proto.stat.Service.GetStat:output_type -&gt; internal.app.proto.stat.StatsResponse
        1, // 3: internal.app.proto.stat.Service.Ping:output_type -&gt; internal.app.proto.stat.PingResponse
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_internal_app_proto_proto_proto_init() }</span>
func file_internal_app_proto_proto_proto_init() <span class="cov8" title="1">{
        if File_internal_app_proto_proto_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_internal_app_proto_proto_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_internal_app_proto_proto_proto_goTypes,
                DependencyIndexes: file_internal_app_proto_proto_proto_depIdxs,
                MessageInfos:      file_internal_app_proto_proto_proto_msgTypes,
        }.Build()
        File_internal_app_proto_proto_proto = out.File
        file_internal_app_proto_proto_proto_rawDesc = nil
        file_internal_app_proto_proto_proto_goTypes = nil
        file_internal_app_proto_proto_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: internal/app/proto/proto.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Service_GetStat_FullMethodName = "/internal.app.proto.stat.Service/GetStat"
        Service_Ping_FullMethodName    = "/internal.app.proto.stat.Service/Ping"
)

// ServiceClient is the client API for Service service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceClient interface {
        GetStat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatsResponse, error)
        Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
}

type serviceClient struct {
        cc grpc.ClientConnInterface
}

func NewServiceClient(cc grpc.ClientConnInterface) ServiceClient <span class="cov0" title="0">{
        return &amp;serviceClient{cc}
}</span>

func (c *serviceClient) GetStat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatsResponse)
        err := c.cc.Invoke(ctx, Service_GetStat_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *serviceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PingResponse)
        err := c.cc.Invoke(ctx, Service_Ping_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ServiceServer is the server API for Service service.
// All implementations must embed UnimplementedServiceServer
// for forward compatibility.
type ServiceServer interface {
        GetStat(context.Context, *StatRequest) (*StatsResponse, error)
        Ping(context.Context, *PingRequest) (*PingResponse, error)
        mustEmbedUnimplementedServiceServer()
}

// UnimplementedServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedServiceServer struct{}

func (UnimplementedServiceServer) GetStat(context.Context, *StatRequest) (*StatsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetStat not implemented")
}</span>
func (UnimplementedServiceServer) Ping(context.Context, *PingRequest) (*PingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}</span>
func (UnimplementedServiceServer) mustEmbedUnimplementedServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedServiceServer) testEmbeddedByValue()                 {<span class="cov0" title="0">}</span>

// UnsafeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceServer will
// result in compilation errors.
type UnsafeServiceServer interface {
        mustEmbedUnimplementedServiceServer()
}

func RegisterServiceServer(s grpc.ServiceRegistrar, srv ServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Service_ServiceDesc, srv)</span>
}

func _Service_GetStat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StatRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServer).GetStat(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Service_GetStat_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServer).GetStat(ctx, req.(*StatRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Service_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServer).Ping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Service_Ping_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServer).Ping(ctx, req.(*PingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Service_ServiceDesc is the grpc.ServiceDesc for Service service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Service_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "internal.app.proto.stat.Service",
        HandlerType: (*ServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetStat",
                        Handler:    _Service_GetStat_Handler,
                },
                {
                        MethodName: "Ping",
                        Handler:    _Service_Ping_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "internal/app/proto/proto.proto",
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package proto

import (
        "context"
)

type PingService interface {
        Ping(ctx context.Context) error
}

type StatService interface {
        GetUrlsAndUsersStat() (int32, int32)
}

type Server struct {
        UnimplementedServiceServer
        pingService PingService
        statService StatService
}

func NewGPRCServer(pingService PingService, statService StatService) *Server <span class="cov0" title="0">{
        return &amp;Server{
                pingService: pingService,
                statService: statService,
        }

}</span>

func (s *Server) GetStat(ctx context.Context, r *StatRequest) (*StatsResponse, error) <span class="cov0" title="0">{
        var response StatsResponse

        urlCount, userCount := s.statService.GetUrlsAndUsersStat()

        response.Urls = urlCount
        response.Users = userCount

        return &amp;response, nil
}</span>

func (s *Server) Ping(ctx context.Context, r *PingRequest) (*PingResponse, error) <span class="cov0" title="0">{
        var response PingResponse

        err := s.pingService.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                response.Error = err.Error()
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package filestorage

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/jmoiron/sqlx"
)

// FileStorageReadRepository сервис
type FileStorageReadRepository struct {
        file *os.File
}

// Find поиск
func (repo *FileStorageReadRepository) Find(shortURLs []string, addedUserID string) ([]entity.ShortURLEntity, error) <span class="cov1" title="1">{
        return make([]entity.ShortURLEntity, 0), nil
}</span>

// GetUrlsByUserID получение ссылок по пользователю
func (repo *FileStorageReadRepository) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov1" title="1">{
        var models []entity.ShortURLEntity

        return models, nil
}</span>

// GetDB получение коннекта к репозиторию на чтение
func (repo *FileStorageReadRepository) GetDB() *sqlx.DB <span class="cov1" title="1">{
        return nil
}</span>

// GetDB получение коннекта к репозиторию на запись
func (repo *FileStorageWriteRepository) GetDB() *sqlx.DB <span class="cov1" title="1">{
        return nil
}</span>

// Ping  пинг
func (repo *FileStorageReadRepository) Ping(ctx context.Context) error <span class="cov1" title="1">{
        return nil
}</span>

// FileStorageWriteRepository сервис
type FileStorageWriteRepository struct {
        file *os.File
}

// Batch Массовое сохранение
func (repo *FileStorageWriteRepository) Batch(ents []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov1" title="1">{
        var models []entity.ShortURLEntity
        var shortURL string
        for _, ent := range ents </span><span class="cov2" title="2">{
                shortURL = utils.GenerateShortURL(ent.OriginalURL)
                _, err := repo.file.WriteString(fmt.Sprintf(`{"short_url":"%s","original_url":"%s", "correlation_id":"%s"}`+"\n", shortURL, ent.OriginalURL, ent.CorrelationID))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov2" title="2">models = append(models, entity.ShortURLEntity{ShortURL: shortURL, URL: ent.OriginalURL, CorrelationID: ent.CorrelationID})</span>
        }

        <span class="cov1" title="1">return models, nil</span>
}

// NewFileStorageRepositoryWrite контсруктор на запись
func NewFileStorageRepositoryWrite(path string) (*FileStorageWriteRepository, error) <span class="cov4" title="6">{
        file, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="6">return &amp;FileStorageWriteRepository{file: file}, nil</span>
}

// NewFileStorageRepositoryRead контсруктор на чтение
func NewFileStorageRepositoryRead(path string) (*FileStorageReadRepository, error) <span class="cov4" title="7">{
        file, err := os.OpenFile(path, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="7">return &amp;FileStorageReadRepository{file: file}, nil</span>
}

// FindByShortURL поиск по короткой ссылке
func (repo *FileStorageReadRepository) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov2" title="2">{
        var dto entity.ShortURLEntity

        _, err := repo.file.Seek(0, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">scanner := bufio.NewScanner(repo.file)
        for scanner.Scan() </span><span class="cov10" title="190">{
                if strings.Contains(scanner.Text(), shortURL) </span><span class="cov1" title="1">{
                        err := json.Unmarshal(scanner.Bytes(), &amp;dto)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov1" title="1">return &amp;dto, nil</span>
                }
        }

        <span class="cov1" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

// Save сохранение
func (repo *FileStorageWriteRepository) Save(shortURL, URL, addedUserID string) error <span class="cov2" title="2">{
        _, err := repo.file.WriteString(fmt.Sprintf(`{"short_url":"%s","original_url":"%s", "added_user_id":"%s"}`+"\n", shortURL, URL, addedUserID))

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// Delete удаление
func (repo *FileStorageWriteRepository) Delete(shortURLs []string, addedUserID string) error <span class="cov0" title="0">{
        return nil
}</span>

// SaveToFile при падении ничего не далем
func (repo *FileStorageWriteRepository) SaveToFile(fileName string) error <span class="cov0" title="0">{
        return nil
}</span>

func (repo *FileStorageReadRepository) GetUrlsCount() int32 <span class="cov0" title="0">{
        return 0
}</span>

func (repo *FileStorageReadRepository) GetUsersCount() int32 <span class="cov0" title="0">{
        return 0
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package localstorage

import (
        "bufio"
        "context"
        "encoding/json"
        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/jmoiron/sqlx"
        "os"
)

// LocalStorageRepository сервис
type LocalStorageRepository struct {
        Rows map[string]LocalStorageRow
}

// GetUrlsByUserID получение ссылок по пользователю
func (repo *LocalStorageRepository) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov1" title="1">{
        var models []entity.ShortURLEntity
        return models, nil
}</span>

// LocalStorageRow сервис
type LocalStorageRow struct {
        ShortURL      string
        URL           string
        CorrelationID string
        AddedUserID   string
}

// Batch Массовое сохранение
func (repo *LocalStorageRepository) Batch(ents []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov1" title="1">{
        var shortURL string
        var models []entity.ShortURLEntity
        for _, ent := range ents </span><span class="cov3" title="2">{
                shortURL = utils.GenerateShortURL(ent.OriginalURL)
                repo.Rows[shortURL] = LocalStorageRow{ShortURL: shortURL, URL: ent.OriginalURL, CorrelationID: ent.CorrelationID}
                models = append(models, entity.ShortURLEntity{ShortURL: shortURL, URL: ent.OriginalURL, CorrelationID: ent.CorrelationID})
        }</span>

        <span class="cov1" title="1">return models, nil</span>
}

// NewLocalStorageRepository конструктор
func NewLocalStorageRepository() *LocalStorageRepository <span class="cov10" title="9">{
        return &amp;LocalStorageRepository{
                Rows: make(map[string]LocalStorageRow),
        }
}</span>

// FindByShortURL поиск по короткой ссылке
func (repo *LocalStorageRepository) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov3" title="2">{
        if row, exists := repo.Rows[shortURL]; exists </span><span class="cov1" title="1">{
                return &amp;(entity.ShortURLEntity{ShortURL: row.ShortURL, URL: row.URL, CorrelationID: row.CorrelationID}), nil
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

// Save сохранение
func (repo *LocalStorageRepository) Save(shortURL, URL, addedUserID string) error <span class="cov5" title="3">{
        repo.Rows[shortURL] = LocalStorageRow{ShortURL: shortURL, URL: URL, AddedUserID: addedUserID}

        return nil
}</span>

// Ping  пинг
func (repo *LocalStorageRepository) Ping(ctx context.Context) error <span class="cov1" title="1">{

        return nil
}</span>

// GetDB получение коннекта к репозиторию
func (repo *LocalStorageRepository) GetDB() *sqlx.DB <span class="cov1" title="1">{
        return nil
}</span>

// Delete удаление
func (repo *LocalStorageRepository) Delete(shortURLs []string, addedUserID string) error <span class="cov1" title="1">{
        return nil
}</span>

// SaveToFile сохраняем текущее состояние в файл при падении
func (repo *LocalStorageRepository) SaveToFile(fileName string) error <span class="cov1" title="1">{
        file, err := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer file.Close()
        writer := bufio.NewWriter(file)
        encoder := json.NewEncoder(writer)
        for _, v := range repo.Rows </span><span class="cov1" title="1">{
                err = encoder.Encode(v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">err = writer.Flush()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (repo *LocalStorageRepository) GetUrlsCount() int32 <span class="cov0" title="0">{
        return 0
}</span>
func (repo *LocalStorageRepository) GetUsersCount() int32 <span class="cov0" title="0">{
        return 0
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package postgres

import (
        "context"
        "fmt"
        "strings"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// TableName имя таблицы
const TableName = "url"

// Количество записей на одну вставвку
const ButchSize = 100

// PostgresRepository сервис
type PostgresRepository struct {
        DB *sqlx.DB
}

// NewPostgresRepository конструктор
func NewPostgresRepository(DB *sqlx.DB) (*PostgresRepository, error) <span class="cov0" title="0">{
        return &amp;PostgresRepository{DB: DB}, nil
}</span>

// Ping  пинг
func (repo *PostgresRepository) Ping(ctx context.Context) error <span class="cov1" title="1">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("прервали работу")</span>
        default:<span class="cov1" title="1">
                return repo.DB.Ping()</span>
        }
}

// FindByShortURL поиск по короткой ссылке
func (repo *PostgresRepository) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov1" title="1">{

        ent := []entity.ShortURLEntity{}
        err := repo.DB.Select(&amp;ent,
                fmt.Sprintf("select url_full as original_url, url_short, is_deleted from %s where url_short = $1", TableName),
                shortURL)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if len(ent) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">return &amp;ent[0], nil</span>
}

// Save сохранение
func (repo *PostgresRepository) Save(shortURL, URL, addedUserID string) error <span class="cov0" title="0">{

        id := uuid.New().String()
        _, err := repo.DB.Exec(fmt.Sprintf(`INSERT into %s (id, url_full, url_short, added_user_id) values ($1, $2, $3, $4)`, TableName), id, URL, shortURL, addedUserID)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDB получение коннекта к репозиторию
func (repo *PostgresRepository) GetDB() *sqlx.DB <span class="cov0" title="0">{
        return repo.DB
}</span>

// Batch Массовое сохранение
func (repo *PostgresRepository) Batch(request []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov1" title="1">{
        var models []entity.ShortURLEntity
        var allModels []entity.ShortURLEntity

        tx, err := repo.DB.Begin()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">k := 0
        var values []string
        var params []interface{}

        for i, item := range request </span><span class="cov10" title="2">{
                models = append(models, entity.ShortURLEntity{URL: item.OriginalURL, CorrelationID: item.CorrelationID, ShortURL: utils.GenerateShortURL(item.OriginalURL)})

                if len(models) == ButchSize || len(request) == i+1 </span><span class="cov1" title="1">{
                        values = nil
                        params = nil
                        for _, enty := range models </span><span class="cov10" title="2">{
                                values = append(values, "("+
                                        "$"+fmt.Sprintf("%d,", k+1)+
                                        "$"+fmt.Sprintf("%d,", k+2)+
                                        "$"+fmt.Sprintf("%d,", k+3)+
                                        "$"+fmt.Sprintf("%d", k+4)+")")
                                params = append(params, uuid.New().String(), enty.URL, enty.ShortURL, enty.CorrelationID)
                                k += 4
                        }</span>

                        <span class="cov1" title="1">valuesStr := strings.Join(values, ",")
                        _, err = repo.DB.Exec(fmt.Sprintf(`INSERT into %s values %s`, TableName, valuesStr), params...)
                        if err != nil </span><span class="cov0" title="0">{
                                err2 := tx.Rollback()
                                if err2 != nil </span><span class="cov0" title="0">{
                                        return nil, err2
                                }</span>
                                <span class="cov0" title="0">return nil, err</span>
                        }
                        <span class="cov1" title="1">allModels = append(allModels, models...)
                        models = nil</span>
                }
        }

        <span class="cov1" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return allModels, nil</span>
}

// GetUrlsByUserID получение ссылок по пользователю
func (repo *PostgresRepository) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov1" title="1">{
        ent := []entity.ShortURLEntity{}

        err := repo.DB.Select(&amp;ent,
                fmt.Sprintf("select url_full as original_url, url_short from %s where added_user_id = $1", TableName),
                userID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return ent, nil</span>
}

// Delete удаление
func (repo *PostgresRepository) Delete(shortURLs []string, addedUserID string) error <span class="cov1" title="1">{
        var inArray []string
        var params []interface{}

        params = append(params, addedUserID)
        i := 2
        for _, shortURL := range shortURLs </span><span class="cov10" title="2">{
                inArray = append(inArray, "$"+fmt.Sprintf("%d", i))
                params = append(params, shortURL)
                i++
        }</span>
        <span class="cov1" title="1">_, err := repo.DB.Exec(fmt.Sprintf(`update %s SET is_deleted = true WHERE added_user_id = $1 AND url_short IN (%s)`, TableName, strings.Join(inArray, ",")), params...)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// SaveToFile при падении ничего не далем
func (repo *PostgresRepository) SaveToFile(fileName string) error <span class="cov0" title="0">{
        return nil
}</span>

// getUrlsCount
func (repo *PostgresRepository) GetUrlsCount() int32 <span class="cov0" title="0">{
        var count int32

        err := repo.DB.QueryRow(fmt.Sprintf("select COUNT(*) from %s", TableName)).Scan(&amp;count)

        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return count</span>
}

// getUsersCount
func (repo *PostgresRepository) GetUsersCount() int32 <span class="cov0" title="0">{
        var count int32

        err := repo.DB.QueryRow(fmt.Sprintf("select COUNT(DISTINCT added_user_id) from %s", TableName)).Scan(&amp;count)

        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return count</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import "context"

// PingService сервис
type PingService struct {
        repository RepositoryReader
}

// NewPingService Конструктор
func NewPingService(repository RepositoryReader) *PingService <span class="cov8" title="1">{
        return &amp;PingService{repository: repository}
}</span>

// Ping пиннг
func (s *PingService) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return s.repository.Ping(ctx)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/arturturundaev/shorturl/internal/app/entity"
        "github.com/arturturundaev/shorturl/internal/app/handler/batch"
        "github.com/arturturundaev/shorturl/internal/app/middleware"
        "github.com/arturturundaev/shorturl/internal/app/utils"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// ShortURLService сервис
type ShortURLService struct {
        repositoryRead  RepositoryReader
        repositoryWrite RepositoryWriter
        logger          *zap.Logger
}

// ErrEntityExists ошибка нет записи
var ErrEntityExists = errors.New("entity exists")

// NewShortURLService конструктор
func NewShortURLService(repositoryRead RepositoryReader, repositoryWrite RepositoryWriter) *ShortURLService <span class="cov3" title="2">{
        return &amp;ShortURLService{repositoryRead: repositoryRead, repositoryWrite: repositoryWrite}
}</span>

// FindByShortURL поиск по короткой ссылке
func (service *ShortURLService) FindByShortURL(shortURL string) (*entity.ShortURLEntity, error) <span class="cov4" title="3">{
        return service.repositoryRead.FindByShortURL(shortURL)
}</span>

// Save сохранение
func (service *ShortURLService) Save(ctx *gin.Context, url string) (*entity.ShortURLEntity, error) <span class="cov4" title="3">{
        addedUserID, exists := ctx.Get(middleware.UserIDProperty)

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user id is required")
        }</span>

        <span class="cov4" title="3">shortURL := utils.GenerateShortURL(url)

        model, errRepository := service.repositoryRead.FindByShortURL(shortURL)

        if errRepository != nil </span><span class="cov0" title="0">{
                return nil, errRepository
        }</span>

        <span class="cov4" title="3">if model != nil </span><span class="cov0" title="0">{
                return model, ErrEntityExists
        }</span>

        <span class="cov4" title="3">err := service.repositoryWrite.Save(shortURL, url, addedUserID.(string))

        if err != nil </span><span class="cov3" title="2">{
                return &amp;entity.ShortURLEntity{ShortURL: shortURL, URL: url}, err
        }</span>

        <span class="cov1" title="1">return &amp;entity.ShortURLEntity{ShortURL: shortURL, URL: url}, nil</span>
}

// Batch Массовое сохранение
func (service *ShortURLService) Batch(request []batch.ButchRequest) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        return service.repositoryWrite.Batch(request)
}</span>

// GetUrlsByUserID получение ссылок по пользователю
func (service *ShortURLService) GetUrlsByUserID(userID string) ([]entity.ShortURLEntity, error) <span class="cov0" title="0">{
        return service.repositoryRead.GetUrlsByUserID(userID)
}</span>

// Delete удаление
func (service *ShortURLService) Delete(URLList []string, addedUserID string) <span class="cov1" title="1">{
        var chunk []string
        var chunks [][]string
        i := 0
        for _, URL := range URLList </span><span class="cov10" title="12">{
                chunk = append(chunk, URL)

                if i &lt; 10 </span><span class="cov9" title="11">{
                        i++
                }</span> else<span class="cov1" title="1"> {
                        chunks = append(chunks, chunk)
                        chunk = nil
                        i = 0
                }</span>

        }

        <span class="cov1" title="1">var deletedURLs []string
        if len(chunk) &gt; 0 </span><span class="cov1" title="1">{
                chunks = append(chunks, chunk)
                chunk = nil
        }</span>

        <span class="cov1" title="1">inCh := service.sendToPrepare(chunks)
        ch1 := service.prepareGoodURL(inCh, addedUserID)
        ch2 := service.prepareGoodURL(inCh, addedUserID)
        for n := range service.fanIn(ch1, ch2) </span><span class="cov3" title="2">{
                deletedURLs = append(deletedURLs, n...)
        }</span>

        <span class="cov1" title="1">service.notification(deletedURLs)</span>
}

// sendToPrepare отправляем в поток на обработку
func (service *ShortURLService) sendToPrepare(chunks [][]string) chan []string <span class="cov1" title="1">{
        outCh := make(chan []string)
        go func() </span><span class="cov1" title="1">{
                defer close(outCh)
                for _, chunk := range chunks </span><span class="cov3" title="2">{
                        outCh &lt;- chunk
                }</span>
        }()

        <span class="cov1" title="1">return outCh</span>
}

// Возвращаем только те URL, которые действо можно удалить
func (service *ShortURLService) prepareGoodURL(inCh chan []string, addedUserID string) chan []string <span class="cov3" title="2">{
        outCh := make(chan []string)

        go func() </span><span class="cov3" title="2">{
                defer close(outCh)
                for shortURLs := range inCh </span><span class="cov3" title="2">{
                        err := service.repositoryWrite.Delete(shortURLs, addedUserID)
                        if err != nil </span><span class="cov0" title="0">{
                                service.logger.Error("ошибка получения записей", zap.String("urls", strings.Join(shortURLs, ",")), zap.String("addedUserID", addedUserID), zap.Error(err))
                                return
                        }</span>

                        <span class="cov3" title="2">outCh &lt;- shortURLs</span>
                }
        }()

        <span class="cov3" title="2">return outCh</span>
}

// fanIn обработка потока
func (service *ShortURLService) fanIn(chs ...chan []string) chan []string <span class="cov1" title="1">{
        var wg sync.WaitGroup
        outCh := make(chan []string)

        // определяем функцию output для каждого канала в chs
        // функция output копирует значения из канала с в канал outCh, пока с не будет закрыт
        output := func(c chan []string) </span><span class="cov3" title="2">{
                for n := range c </span><span class="cov3" title="2">{
                        outCh &lt;- n
                }</span>
                <span class="cov3" title="2">wg.Done()</span>
        }

        // добавляем в группу столько горутин, сколько каналов пришло в fanIn
        <span class="cov1" title="1">wg.Add(len(chs))
        // перебираем все каналы, которые пришли и отправляем каждый в отдельную горутину
        for _, c := range chs </span><span class="cov3" title="2">{
                go output(c)
        }</span>

        // запускаем горутину для закрытия outCh после того, как все горутины отработают
        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                wg.Wait()
                close(outCh)
        }</span>()

        // возвращаем общий канал
        <span class="cov1" title="1">return outCh</span>
}

// notification уведомление о обработанных письмах
func (service *ShortURLService) notification(URLs []string) {<span class="cov1" title="1">
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package service

type StatService struct {
        repository getStatsRepository
}

type getStatsRepository interface {
        GetUrlsCount() int32
        GetUsersCount() int32
}

func NewStatService(repository getStatsRepository) *StatService <span class="cov8" title="1">{
        return &amp;StatService{repository: repository}
}</span>

func (s *StatService) GetUrlsAndUsersStat() (int32, int32) <span class="cov8" title="1">{
        urlsCount := s.repository.GetUrlsCount()
        usersCount := s.repository.GetUsersCount()

        return urlsCount, usersCount
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package utils

import (
        "crypto/sha1"
        "encoding/base64"
)

// GenerateShortURL формированиерое краткого url
func GenerateShortURL(url string) string <span class="cov10" title="14">{
        hash := sha1.New()
        hash.Write([]byte(url))
        return base64.URLEncoding.EncodeToString(hash.Sum(nil))[:8]

}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package config

//  -a=http://localhost:8081/api/shorten -b=http://localhost:8081/api/shorten
import (
        "bytes"
        "cmp"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/json"
        "encoding/pem"
        "flag"
        "log"
        "math/big"
        "net"
        "os"
        "strconv"
        "strings"
        "time"
)

// Config структура
type Config struct {
        AddressStart string `json:"server_address"`
        BaseShort    string `json:"base_url"`
        FileStorage  string `json:"file_storage_path"`
        DatabaseURL  string `json:"database_dsn"`
        StorageType  string
        FullLog      bool
        HTTPS        struct {
                Enabled    bool `json:"enable_https"`
                SSLKeyPath string
                SSLPemPath string
        }
        TrustedSubnet      string `json:"trusted_subnet"`
        TrustedSubnetFinal []*net.IPNet
        GRPCAddr           string `json:"grpc_address"`
}

// StorageTypeMemory место зранения
const StorageTypeMemory = "Memory"

// StorageTypeFile место зранения
const StorageTypeFile = "File"

// StorageTypeDB место зранения
const StorageTypeDB = "DB"

// NewConfig получение конфигов
func NewConfig() *Config <span class="cov1" title="1">{
        var configPath string
        flag.StringVar(&amp;configPath, "c", "", "Path to config file")

        cfg := &amp;Config{}

        flag.StringVar(&amp;cfg.AddressStart, "a", "", "start url and port")
        flag.StringVar(&amp;cfg.BaseShort, "b", "", "url redirect")
        flag.StringVar(&amp;cfg.FileStorage, "f", "", "file storage path")
        flag.StringVar(&amp;cfg.DatabaseURL, "d", "", "database storage path")
        flag.BoolVar(&amp;cfg.HTTPS.Enabled, "s", false, "ssl enabled")
        flag.StringVar(&amp;cfg.HTTPS.SSLKeyPath, "sslk", "./auto_server.key", "Path to ssl key file")
        flag.StringVar(&amp;cfg.HTTPS.SSLPemPath, "sslp", "./auto_server.pem", "Path to ssl pem file")
        flag.StringVar(&amp;cfg.TrustedSubnet, "t", "", "Path to ssl pem file")
        flag.StringVar(&amp;cfg.GRPCAddr, "g", "", "grpc server")
        flag.Parse()

        preConfig := &amp;Config{}
        if configPath != "" </span><span class="cov0" title="0">{
                rawContent, err := os.ReadFile(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">if err = json.Unmarshal(rawContent, preConfig); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }

        <span class="cov1" title="1">cfg.AddressStart = cmp.Or(cfg.AddressStart, os.Getenv("SERVER_ADDRESS"), preConfig.AddressStart, "localhost:8080")
        cfg.BaseShort = cmp.Or(cfg.BaseShort, os.Getenv("BASE_URL"), preConfig.BaseShort, "http://localhost:8080")
        cfg.FileStorage = cmp.Or(cfg.FileStorage, os.Getenv("FILE_STORAGE_PATH"), preConfig.FileStorage)
        cfg.DatabaseURL = cmp.Or(cfg.DatabaseURL, os.Getenv("DATABASE_DSN"), preConfig.DatabaseURL)
        cfg.TrustedSubnet = cmp.Or(cfg.TrustedSubnet, os.Getenv("TRUSTED_SUBNET"), preConfig.TrustedSubnet)
        cfg.GRPCAddr = cmp.Or(cfg.GRPCAddr, os.Getenv("GRPC_ADDR"), preConfig.GRPCAddr)

        var storageType = StorageTypeMemory

        if cfg.FileStorage != "" || os.Getenv("FILE_STORAGE_PATH") != "" </span><span class="cov1" title="1">{
                storageType = StorageTypeFile
        }</span>

        <span class="cov1" title="1">if cfg.DatabaseURL != "" || os.Getenv("DATABASE_DSN") != "" </span><span class="cov1" title="1">{
                storageType = StorageTypeDB
        }</span>

        <span class="cov1" title="1">cfg.StorageType = storageType
        cfg.FullLog = true

        if envHTTPSStr := os.Getenv("ENABLE_HTTPS"); envHTTPSStr != "" </span><span class="cov1" title="1">{
                envHTTPS, err := strconv.ParseBool(envHTTPSStr)
                if err == nil </span><span class="cov1" title="1">{
                        cfg.HTTPS.Enabled = envHTTPS
                }</span>
        }

        <span class="cov1" title="1">if cfg.HTTPS.Enabled &amp;&amp; cfg.HTTPS.SSLKeyPath == "./auto_server.key" </span><span class="cov1" title="1">{
                CreateTLSCert("./auto_server.pem", "./auto_server.key")
        }</span>

        <span class="cov1" title="1">cfg.TrustedSubnetFinal = prepareTrustedSubnets(cfg.TrustedSubnet)

        return cfg</span>
}

// CreateTLSCert - generate TLS certificate and key for run server HTTPS
func CreateTLSCert(certPath string, keyPath string) error <span class="cov1" title="1">{
        cert := x509.Certificate{
                SerialNumber: big.NewInt(1),
                Subject: pkix.Name{
                        Organization: []string{"artur.turundaev"},
                        Country:      []string{"RU"},
                        Province:     []string{"Moscow"},
                        Locality:     []string{"Moscow"},
                        CommonName:   "localhost",
                },
                NotBefore:             time.Now(),
                NotAfter:              time.Now().Add(365 * 24 * time.Hour),
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
                IPAddresses:           []net.IP{net.ParseIP("127.0.0.1")},
        }

        privateKey, _ := rsa.GenerateKey(rand.Reader, 4096)
        certBytes, _ := x509.CreateCertificate(rand.Reader, &amp;cert, &amp;cert, &amp;privateKey.PublicKey, privateKey)
        err := saveToFile(certPath, "CERTIFICATE", certBytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = saveToFile(keyPath, "RSA PRIVATE KEY", x509.MarshalPKCS1PrivateKey(privateKey))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func saveToFile(filePath string, cypherType string, cypher []byte) error <span class="cov10" title="2">{
        var (
                buf  bytes.Buffer
                file *os.File
        )

        _ = pem.Encode(&amp;buf, &amp;pem.Block{
                Type:  cypherType,
                Bytes: cypher,
        })

        file, _ = os.Create(filePath)
        defer file.Close()

        _, err := buf.WriteTo(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="2">return nil</span>
}

func prepareTrustedSubnets(data string) []*net.IPNet <span class="cov1" title="1">{
        var subnets []*net.IPNet
        if data != "" </span><span class="cov1" title="1">{
                subStr := strings.Split(data, ",")
                for _, subnetStr := range subStr </span><span class="cov1" title="1">{
                        _, subnetIPNet, _ := net.ParseCIDR(subnetStr)
                        subnets = append(subnets, subnetIPNet)
                }</span>
        }

        <span class="cov1" title="1">return subnets</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package exitmain

import (
        "go/ast"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "honnef.co/go/tools/analysis/code"
        "strings"
)

// Analyzer - Check direct call to os.Exit in the main function
var Analyzer = &amp;analysis.Analyzer{
        Name:     "mainexit",
        Doc:      "Checking the use of a direct call to os.Exit in the main function of the main package",
        Run:      run,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
}

func run(pass *analysis.Pass) (interface{}, error) <span class="cov3" title="2">{
        if pass.Pkg.Name() != "main" </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">fn := func(node ast.Node) </span><span class="cov3" title="2">{
                switch v := node.(type) </span>{
                case *ast.FuncDecl:<span class="cov3" title="2">
                        if v.Body == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov3" title="2">if v.Name.Name != "main" </span><span class="cov1" title="1">{
                                return
                        }</span>

                        <span class="cov1" title="1">if strings.HasSuffix(pass.Pkg.Path(), ".example") ||
                                strings.HasSuffix(pass.Pkg.Path(), ".test") ||
                                strings.HasSuffix(pass.Pkg.Path(), "benchmark") ||
                                strings.HasSuffix(pass.Pkg.Path(), "fuzz") </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov1" title="1">ast.Inspect(v, func(n ast.Node) bool </span><span class="cov10" title="22">{
                                ce, okCe := n.(*ast.CallExpr)
                                if !okCe </span><span class="cov9" title="19">{
                                        return true
                                }</span>

                                <span class="cov4" title="3">se, okSe := ce.Fun.(*ast.SelectorExpr)
                                if !okSe </span><span class="cov1" title="1">{
                                        return true
                                }</span>

                                <span class="cov3" title="2">if ident, ok := se.X.(*ast.Ident); ok &amp;&amp; ident.Name == "os" &amp;&amp; se.Sel.Name == "Exit" </span><span class="cov1" title="1">{
                                        pass.Reportf(se.Pos(), "avoid using os.Exit directly in main function")
                                }</span>

                                <span class="cov3" title="2">return false</span>
                        })
                }
        }
        //
        <span class="cov1" title="1">needle := []ast.Node{
                (*ast.FuncDecl)(nil),
        }

        code.Preorder(pass, fn, needle...)

        return nil, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
